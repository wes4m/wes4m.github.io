<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Side Project #9837: Visual Nodes Scripting | wes4m</title>
<meta name=keywords content="dev,golang">
<meta name=description content="Walkthrough implementing a data-flow-ishy nodes executor.">
<meta name=author content="wes4m">
<link rel=canonical href=https://wes4m.io/posts/ta-dataflow-programming/>
<link crossorigin=anonymous href=/assets/css/stylesheet.c266585e349dd9ce670351e0239f03ee0ebc4ca57cc47e0fd0d98f00e50aee7e.css integrity="sha256-wmZYXjSd2c5nA1HgI58D7g68TKV8xH4P0NmPAOUK7n4=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wes4m.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://wes4m.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://wes4m.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://wes4m.io/apple-touch-icon.png>
<link rel=mask-icon href=https://wes4m.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<script src=/dist/webcomponents-loader.js></script>
<script src=/dist/gif-player.es6.js defer async></script>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-X4Z7CWYY5B"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-X4Z7CWYY5B',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Side Project #9837: Visual Nodes Scripting">
<meta property="og:description" content="Walkthrough implementing a data-flow-ishy nodes executor.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://wes4m.io/posts/ta-dataflow-programming/">
<meta property="og:image" content="https://wes4m.io/%3Cimage%20path/url%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2023-02-10T22:59:52+03:00">
<meta property="article:modified_time" content="2023-02-10T22:59:52+03:00"><meta property="og:site_name" content="wes4m">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://wes4m.io/%3Cimage%20path/url%3E">
<meta name=twitter:title content="Side Project #9837: Visual Nodes Scripting">
<meta name=twitter:description content="Walkthrough implementing a data-flow-ishy nodes executor.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wes4m.io/posts/"},{"@type":"ListItem","position":2,"name":"Side Project #9837: Visual Nodes Scripting","item":"https://wes4m.io/posts/ta-dataflow-programming/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Side Project #9837: Visual Nodes Scripting","name":"Side Project #9837: Visual Nodes Scripting","description":"Walkthrough implementing a data-flow-ishy nodes executor.","keywords":["dev","golang"],"articleBody":"There are many visual programming implementations out there that make approaching some specific tasks easier. One of which is Unreal Engine’s Blueprint’s system.\nIt provides game developers with a way to program visually by connecting different nodes. Each node taking in some inputs, and/or options, doing something with it, then outputting the results. You can also implement your own re-useable nodes using C++. It’s apparently turing complete too.\nI wanted to make something similar for a project I’m working on, which brings us to: Data Flow Programming, Flow Based Programming, Node Graph Architecture, and a thousand other names.\n  In computer programming, flow-based programming is a programming paradigm that defines applications as networks of “black box” processes, which exchange data across predefined connections by message passing, where the connections are specified externally to the processes\n  In computer programming, dataflow programming is a programming paradigm that models a program as a directed graph of the data flowing between operations, thus implementing dataflow principles and architecture\n I like to think of flow-based programming as a subset of data-flow programming, as the definition of the latter seems to be broader. Data-flow programming implements data-flow principles and architecture. Meaning that it implements something other than the conventional control-flow (instruction counter) computers we usually use. But of-course, Unreal Engine is not using data-flow hardware, and is not really emulating a “real” data-flow based paradigm. It is just a visual scripting implementation for a specific use case that tries to be as encompassing as possible for game devs.\nI started implementing my own specific use case. I also wanted to have fun doing it so I avoided looking at unreal engine’s source code or any other implementations.\nThe General Idea  I wanted to execute a simplified specialised program structured as a set of nodes, and connections. Each node can have a type, inputs, and outputs, Node type decides what the node does with the inputs. Each execution cycle should start with a clean(new) state? Each execution cycle should start when a special type of node (producer node) produces an output. A program can have multiple producer nodes.  Execution flow The most interesting part in my opinion is building an effeicent nodes execution algorithm, a simple but fun problem. Where does it start from (entry point node?) What about multiple entry points? What happens if the nodes graph has a cycle?\nMany graph theory concepts will be applicable here. Including a quick answer to the last question by restricting the program graph to be a DAG (Directed Acyclic Graph).\nLet’s start with a possible node\ntype valueType string type nodeType string const ( PRODUCER_NODE nodeType = \"PRODUCER\" ARITHMETIC_NODE nodeType = \"ARITHMETIC\" CONSTANT_NODE nodeType = \"CONSTANT\" ) const ( NUMBER_VALUE valueType = \"NUMBER\" ) type value struct { Type valueType value interface{} } type values map[string]value type additionalData map[string]interface{} type connection struct { nodeId string outputId string inputId string } type node struct { id string Type nodeType inConnections []connection outConnections []connection additionalData additionalData } Each node will have an executor based on its type. Having the node implement an interface or some generic approach like a mapping of executors is a better way to do this. However for the sake of simplicity here is a switch statement.\nfunc executeNode(n node) (executed bool, outputs values) { switch n.Type { case PRODUCER_NODE: // ..  return true, values{\"O1\": {Type: NUMBER_VALUE, value: 5}} // ..  // ..  default: return false, nil } } Given all the requirements. Say we have this simple adder program that takes two inputs\n I have one input, one node that provides a constant value, and an adder node which will sum both inputs and output the result. In this case my input acts like a producer node which once an input is available will trigger an execution cycle.\nSo where should the execution start from? One naive approach could be to just:\n Loop through all nodes (no specific order).  Attempt to execute node if not already executed. If all inputs required by the node are available, and the node is executed. Mark it as executed. Continue looping until all nodes are marked executed.    nodes := []node{ {id: \"N1\", Type: PRODUCER_NODE}, {id: \"N2\", Type: CONSTANT_NODE}, {id: \"N3\", Type: ARITHMETIC_NODE}, } for { isAllNodesExecuted := true for _, n := range nodes { executed, _ := executeNode(n) if !executed { isAllNodesExecuted = false } } if isAllNodesExecuted { break } } Currently there is no way to pass around outputs, so this will not really execute. However, This non-determinsitc entry-point/s approach should work for the given program.\n However, if any node in the program has some unpopulated/not-connected input it will loop forever. Another major issue is the performance. To execute a full cycle we have to loop through and attempt to execute each node multiple times. Like in the above program, It happened that the execution started at the adder node causing it to loop twice until all nodes were executed. Had the execution started on the constant value node the program would’ve executed in one iteration.\nWhat about a deterministic entry-point/s approach? In which the program starts executing from multiple nodes, in no specific order also, that are known to be able to execute successfully with regards to their inputs.\nMeaning that an entry-point node is any node that is able to execute with no connections.\nFor this approach:\n Loop through all nodes trying to find any node that fits the entry-point criteria and store it somewhere. Loop through all entry-point nodes and attempt to execute each one.  startingNodesIds := []string{} for _, n := range nodes { if len(n.inConnections) == 0 { startingNodesIds = append(startingNodesIds, n.id) } } // ... .. for _, nodeId := range startingNodesIds { executeNode(strategy, strategy.Nodes[nodeId], \u0026executionTable) }  This however misses one critical part. The execution is stopping at the entry-point/s and is not proceeding forward to any connections going out from it.\nTo solve this, we can recursively execute the nodes:\n When executing a node, loop through it’s out connections For each out conneciton, find the node its connected to and attempt to execute it.  func executeNodeRecursive(nodes map[string]node, n node.Node) { if _, executed := // ..  { // * Already executed, no-op  return } inputs := // ..  // * Execute node  outputs, executed, err := executors.Execute(n, inputs) if err != nil { // * Error executing, no-op  return } if executed { // * Follow node outConnections recuresively  for _, outConnection := range n.outConnections { executeNodeRecursive(nodes, nodes[outConnection.nodeId]) } } }  At this point the only thing missing is a method to populate node inputs with its connected outputs (some sort of node’s state)\nAt the beginning I made each node handle its own state, by storing its executed flag, inputs, and outputs. and letting each node populate its outConnections node’s inputs. But, in order to decouple the state for later usage, and to have some sort of time-travel debug-ability I decided to store the state of each cycle in a separate structure. The structure being just a simple mapping of the nodes and their outputs.\ntype executionTable map[string]values func (extbl *executionTable) getNodeOutputs(nodeId string) (outputs values, executed bool) { if outputs, executed := (*extbl)[nodeId]; executed { return outputs, executed } return nil, false } func (extbl *executionTable) setNodeOutputs(nodeId string, outputs values) { (*extbl)[nodeId] = outputs } Now when a node is executed, it returns an output, the executor then stores that output in the cycle execution table. Similarly, when a node being executed requires an input, the executor attempts to fetch that input from the cycle execution table. This abstraction made it easier to use a functional approach for executing the programs, which I find easier to reason about in the context of concurrent or multi-threaded applications, and overall less bugs to worry about. It also allowed me to experiment with other fun ideas later on.\nfunc executeCycle(nodes map[string]node) (executionTable, bool) { // * Init an empty execution table  executionTable := executionTable{} // * Find starting nodes IDs (execution starts at nodes that have no inputs required)  // * e.g: constants, and producer nodes  startingNodesIds := []string{} for _, n := range nodes { if len(n.inConnections) == 0 { startingNodesIds = append(startingNodesIds, n.id) } } for _, nodeId := range startingNodesIds { executeNodeRecursive(nodes, nodes[nodeId], \u0026executionTable) } return executionTable, true } func executeNodeRecursive(nodes map[string]node, n node, executionTable *executionTable) { if _, executed := executionTable.getNodeOutputs(n.id); executed { // * Already executed  return } inputs := values{} for _, inConnection := range n.inConnections { if outputs, available := executionTable.getNodeOutputs(inConnection.nodeId); available { if outputValue, ok := outputs[inConnection.outputId]; ok { inputs[inConnection.inputId] = outputValue } } else { // * Inputs considered not fully populated if any dependecy output is missing from the execution table  return } } // * Execute node  outputs, executed, err := executors.Execute(n, inputs) if err != nil { // * Error executing  return } if executed { executionTable.setNodeOutputs(n.id, outputs) // * Follow node outConnections recuresively  for _, outConnection := range n.outConnections { executeNodeRecursive(nodes, nodes[outConnection.nodeId], executionTable) } } } Now I can store each execution cycle table and backtrack, or move forward by providing the execution table at any point (step) in the cycle. Also, I could persist some outputs over multiple cycles if I wanted. If instead I coupled the state with each node, this would’ve been still possible but probably painful to implement, read, and debug.\nSo far this all works fine, I implemented a fake producer that runs in its own goroutine and produces some output every N ms, pre-populating whatever it has produced as part of the node, then triggering an execution cycle every N ms.\nMultiple Producers Since every producer runs in a separate goroutine, When it does produce if ever, is not guaranteed. I made it produce every N ms but this can change depending on the producer settings.\nWhat If I wanted to have multiple producers with varying production rates? (this somewhat represent async I/O)\nIn a case where we have n producer nodes p1, p2, …, pn where for every producer p there is no path in the graph for all p1 to pn to reach any other p; everything will work just fine. Since what we have is essentially multiple program’s graphs each with its own producer.\nHowever, in a program graph where we have multiple producers connecting to a single node. In other words, if any two producers in the program have a path that connects them, then the program will fail to fully execute unless both producers happen to have produced and pre-populated their outputs before triggering an execution cycle. But, this is simply not guaranteed to happen, since each producer will attempt to trigger an execution as soon as it have produced. Which in turn will simply just lock and restart the execution table every time.\nFor my specific use case, all I care about is that I execute the cycle with the latest produced output from each producer.\nFor example, consider that every producer is a ticker. One producer ticks every second, one ticks every minute, and another that ticks every 5 minutes, with all producers having paths to each other.\nI want my program to execute only once it has all of the 3 necessary ticks. To do this, I made each producer store a rolling window of N ticks, calling back to trigger an execution whenever that ticks window has changed. When there is an attempt to execute while there are other producers ticks still missing, the execution does not happen but a ticks synchroniser is flagged for each producer. Once all producers in a program have ticked according to the synchroniser the execution is triggered and the synchroniser is reset.\ntype SafeTicksTracker struct { mu sync.Mutex v map[string]bool } func (c *SafeTicksTracker) Init(producerId string) { c.mu.Lock() c.v[producerId] = false c.mu.Unlock() } func (c *SafeTicksTracker) Tick(producerId string) { c.mu.Lock() c.v[producerId] = true c.mu.Unlock() } func (c *SafeTicksTracker) Reset() { c.mu.Lock() for producerId := range c.v { c.v[producerId] = false } c.mu.Unlock() } func (c *SafeTicksTracker) IsFullyTicked() bool { c.mu.Lock() defer c.mu.Unlock() fullyTicked := true for _, ticked := range c.v { if !ticked { fullyTicked = false } } return fullyTicked } func Stop(stopChans []chan bool) { for _, stop := range stopChans { go func(s chan bool) { s  true }(stop) } } func Start(nodes map[string]node) (stopChans []chan bool, ok bool) { producersStopChans := []chan bool{} ticksTracker := SafeTicksTracker{v: map[string]bool{}} // * Find all producer nodes  producerNodes := map[string]node for _, n := range nodes { if n.Type == PRODUCER_NODE { producerNodeCopy := n producerNodes[n.id] = producerNodeCopy ticksTracker.Init(n.id) } } // * Starting producers  var nodesMapMutex sync.Mutex for _, pn := range producerNodes { // * Each producer will callback to this function (from the producer goroutine context) once its dataWindow is changed and ready to be used in a an execution cycle  started, stopChan := producer.Start(pn, func(producerNodeId string, dataWindow /*...*/) { // * Updating the producer dataWindow with the newly produced data to be used in the execution cycle as outputs  // * A mutex is required to prevent conncurent map writes to the nodes map as dataWindows of different producers are being updated  nodesMapMutex.Lock() nodes[producerNodeId].AdditionalData[\"dataWindow\"] = dataWindow nodesMapMutex.Unlock() /* * A concurrently safe ticks tracker is used to keep track of what producers have produced. * this is implemented such that an execution cycle will only execute if all producers of that set of a program have produced * the tracker is then reset to start the tracking again. So that another cycle of production is awaited from the producers */ ticksTracker.Tick(producerNodeId) if ticksTracker.IsFullyTicked() { ticksTracker.Reset() // * Cycle execution starts  // * this also locks the producers from accessing the nodes map while the cycle is executing  nodesMapMutex.Lock() executeCycle(nodes) nodesMapMutex.Unlock() } }, func(producerNodeId string, err error) { Stop(producersStopChans) }) if !started { // * If any producers failed to start for some reason, clean up by stopping all producers  Stop(producersStopChans) return nil, false } // * Store producer stop channel to be used to stop the producer  producersStopChans = append(producersStopChans, stopChan) } return producersStopChans, true } Since each producer runs in a goroutine, attempting to modify a shared resource (producers synchroniser) some form of locking is necessary; that is why you see the mutex in the code.\nPerformance Remarks Why Golang? Initially, I started the project (which is still a WIP) with Python for the backend, TypeScript for the frontend. Keep In mind that although I’m showing a simple loop producer in here. A producer can be anything, including some heavy I/O operations. So, when stress testing, Python’s GIL stepped in. I converted my implementation to be multiprocessing which was much better. But, overhead for memory, and initial start time for each producer (e.g when I wanted to restart thousands of them) was a major bottleneck.\nZero Down Time Releases? I’m trying to keep the full picture of this side project a little vague here until it’s somewhat ready 😶‍🌫️🥷🏽, So this is a little hard to explain without the full details. But anyway, the program executor above runs as scaleable microservice, which in-turn runs those visual programs indefinitely.\nA simplified idea for a new release: I could schedule some downtime, shutdown the service with its programs. Run the new one and restart all the programs from their latest execution tables.\nHowever, for this project, a restarted program will not execute accurately if you just have a missing window of data between its stop and restart. For example, a program that has some producer producing every second was stopped for 10 minutes before restarting. Now there are 600 missing produced outputs in which an execution result might depend on.\nI solved this using a program service-to-service hand-over/migration allowing all users to still run new programs, and at the same time have already running programs moved to the newly ran service with zero down time.\nI will show this ✨ method in another post.\n","wordCount":"2650","inLanguage":"en","image":"https://wes4m.io/%3Cimage%20path/url%3E","datePublished":"2023-02-10T22:59:52+03:00","dateModified":"2023-02-10T22:59:52+03:00","author":{"@type":"Person","name":"wes4m"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wes4m.io/posts/ta-dataflow-programming/"},"publisher":{"@type":"Organization","name":"wes4m","logo":{"@type":"ImageObject","url":"https://wes4m.io/favicon.ico"}}}</script>
</head>
<body class=dark id=top>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://wes4m.io/ accesskey=h title="./ (Alt + H)">./</a>
<div class=logo-switches>
</div>
</div>
<ul id=menu>
<li>
<a href=https://wes4m.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://wes4m.io/>Home</a>&nbsp;»&nbsp;<a href=https://wes4m.io/posts/>Posts</a></div>
<h1 class=post-title dir=ltr>
Side Project #9837: Visual Nodes Scripting
</h1>
<div class=post-description dir=ltr>
Walkthrough implementing a data-flow-ishy nodes executor.
</div>
<div class=post-meta dir=ltr><span title="2023-02-10 22:59:52 +0300 +0300">February 10, 2023</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;wes4m&nbsp;|&nbsp;<a href=https://github.com/wes4m/wes4m.github.io/tree/drafting/content/posts/ta-dataflow-programming.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content dir=ltr><p>There are many visual programming implementations out there that make approaching some specific tasks easier. One of which is Unreal Engine&rsquo;s Blueprint&rsquo;s system.</p>
<p align=center>
<img src=/images/dfp/blueprint.png>
</p>
<p>It provides game developers with a way to program visually by connecting different nodes. Each node taking in some inputs, and/or options, doing something with it, then outputting the results. You can also implement your own re-useable nodes using C++. It&rsquo;s apparently turing complete too.</p>
<p>I wanted to make something similar for a project I&rsquo;m working on, which brings us to: Data Flow Programming, Flow Based Programming, Node Graph Architecture, and a thousand other names.</p>
<center><iframe src=https://giphy.com/embed/WRQBXSCnEFJIuxktnw width=480 height=250 frameborder=0 class=giphy-embed allowfullscreen></iframe></center>
<blockquote>
<p>In computer programming, flow-based programming is a programming paradigm that defines applications as networks of &ldquo;black box&rdquo; processes, which exchange data across predefined connections by message passing, where the connections are specified externally to the processes</p>
</blockquote>
<blockquote>
<p>In computer programming, dataflow programming is a programming paradigm that models a program as a directed graph of the data flowing between operations, thus implementing dataflow principles and architecture</p>
</blockquote>
<p>I like to think of flow-based programming as a subset of data-flow programming, as the definition of the latter seems to be broader. Data-flow programming implements data-flow principles and architecture. Meaning that it implements something other than the conventional control-flow (instruction counter) computers we usually use. But of-course, Unreal Engine is not using data-flow hardware, and is not really emulating a &ldquo;real&rdquo; data-flow based paradigm. It is just a visual scripting implementation for a specific use case that tries to be as encompassing as possible for game devs.</p>
<p>I started implementing my own specific use case. I also wanted to have fun doing it so I avoided looking at unreal engine&rsquo;s source code or any other implementations.</p>
<h2 id=the-general-idea>The General Idea<a hidden class=anchor aria-hidden=true href=#the-general-idea>#</a></h2>
<ol>
<li>I wanted to execute a simplified specialised program structured as a set of nodes, and connections.</li>
<li>Each node can have a type, inputs, and outputs,</li>
<li>Node type decides what the node does with the inputs.</li>
<li>Each execution cycle should start with a clean(new) state?</li>
<li>Each execution cycle should start when a special type of node (producer node) produces an output.</li>
<li>A program can have multiple producer nodes.</li>
</ol>
<h2 id=execution-flow>Execution flow<a hidden class=anchor aria-hidden=true href=#execution-flow>#</a></h2>
<p>The most interesting part in my opinion is building an effeicent nodes execution algorithm, a simple but fun problem. Where does it start from (entry point node?) What about multiple entry points? What happens if the nodes graph has a cycle?</p>
<p>Many graph theory concepts will be applicable here. Including a quick answer to the last question by restricting the program graph to be a DAG (Directed Acyclic Graph).</p>
<p>Let&rsquo;s start with a possible node</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>valueType</span> <span class=kt>string</span>
<span class=kd>type</span> <span class=nx>nodeType</span> <span class=kt>string</span>

<span class=kd>const</span> <span class=p>(</span>
  <span class=nx>PRODUCER_NODE</span> <span class=nx>nodeType</span> <span class=p>=</span> <span class=s>&#34;PRODUCER&#34;</span>
  <span class=nx>ARITHMETIC_NODE</span> <span class=nx>nodeType</span> <span class=p>=</span> <span class=s>&#34;ARITHMETIC&#34;</span>
  <span class=nx>CONSTANT_NODE</span> <span class=nx>nodeType</span> <span class=p>=</span> <span class=s>&#34;CONSTANT&#34;</span>
<span class=p>)</span>

<span class=kd>const</span> <span class=p>(</span>
  <span class=nx>NUMBER_VALUE</span> <span class=nx>valueType</span> <span class=p>=</span> <span class=s>&#34;NUMBER&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>value</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>Type</span>  <span class=nx>valueType</span>
  <span class=nx>value</span> <span class=kd>interface</span><span class=p>{}</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>values</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>value</span>
<span class=kd>type</span> <span class=nx>additionalData</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span>

<span class=kd>type</span> <span class=nx>connection</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>nodeId</span>   <span class=kt>string</span>
  <span class=nx>outputId</span> <span class=kt>string</span>
  <span class=nx>inputId</span>  <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>node</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>id</span>             <span class=kt>string</span>
  <span class=nx>Type</span>           <span class=nx>nodeType</span>
  <span class=nx>inConnections</span>  <span class=p>[]</span><span class=nx>connection</span>
  <span class=nx>outConnections</span> <span class=p>[]</span><span class=nx>connection</span>
  <span class=nx>additionalData</span> <span class=nx>additionalData</span>
<span class=p>}</span>
</code></pre></div><p>Each node will have an executor based on its type. Having the node implement an interface or some generic approach like a mapping of executors is a better way to do this. However for the sake of simplicity here is a switch statement.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>executeNode</span><span class=p>(</span><span class=nx>n</span> <span class=nx>node</span><span class=p>)</span> <span class=p>(</span><span class=nx>executed</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>outputs</span> <span class=nx>values</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>switch</span> <span class=nx>n</span><span class=p>.</span><span class=nx>Type</span> <span class=p>{</span>
    <span class=k>case</span> <span class=nx>PRODUCER_NODE</span><span class=p>:</span>
      <span class=c1>// ..
</span><span class=c1></span>      <span class=k>return</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>values</span><span class=p>{</span><span class=s>&#34;O1&#34;</span><span class=p>:</span> <span class=p>{</span><span class=nx>Type</span><span class=p>:</span> <span class=nx>NUMBER_VALUE</span><span class=p>,</span> <span class=nx>value</span><span class=p>:</span> <span class=mi>5</span><span class=p>}}</span>
    <span class=c1>// ..
</span><span class=c1></span>    <span class=c1>// ..
</span><span class=c1></span>    <span class=k>default</span><span class=p>:</span>
      <span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>nil</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Given all the requirements. Say we have this simple adder program that takes two inputs</p>
<center><gif-player src=/images/dfp/1.gif size=contain style="width: 100%; height: 30vh;" prerender play speed=1></gif-player></center>
<p>I have <strong>one input</strong>, <strong>one node that provides a constant value</strong>, and an <strong>adder node</strong> which will sum both inputs and output the result. In this case my input acts like a producer node which once an input is available will trigger an execution cycle.</p>
<p>So where should the execution start from? One naive approach could be to just:</p>
<ol>
<li>Loop through all nodes (no specific order).
<ol>
<li>Attempt to execute node if not already executed.</li>
<li>If all inputs required by the node are available, and the node is executed. Mark it as executed.</li>
<li>Continue looping until all nodes are marked executed.</li>
</ol>
</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=nx>nodes</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>node</span><span class=p>{</span>
  <span class=p>{</span><span class=nx>id</span><span class=p>:</span> <span class=s>&#34;N1&#34;</span><span class=p>,</span> <span class=nx>Type</span><span class=p>:</span> <span class=nx>PRODUCER_NODE</span><span class=p>},</span>
  <span class=p>{</span><span class=nx>id</span><span class=p>:</span> <span class=s>&#34;N2&#34;</span><span class=p>,</span> <span class=nx>Type</span><span class=p>:</span> <span class=nx>CONSTANT_NODE</span><span class=p>},</span>
  <span class=p>{</span><span class=nx>id</span><span class=p>:</span> <span class=s>&#34;N3&#34;</span><span class=p>,</span> <span class=nx>Type</span><span class=p>:</span> <span class=nx>ARITHMETIC_NODE</span><span class=p>},</span>
<span class=p>}</span>

<span class=k>for</span> <span class=p>{</span>
  <span class=nx>isAllNodesExecuted</span> <span class=o>:=</span> <span class=kc>true</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nodes</span> <span class=p>{</span>
    <span class=nx>executed</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nf>executeNode</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
    <span class=k>if</span> <span class=p>!</span><span class=nx>executed</span> <span class=p>{</span>
      <span class=nx>isAllNodesExecuted</span> <span class=p>=</span> <span class=kc>false</span>
    <span class=p>}</span>
  <span class=p>}</span> 
  <span class=k>if</span> <span class=nx>isAllNodesExecuted</span> <span class=p>{</span>
    <span class=k>break</span>
  <span class=p>}</span>
<span class=p>}</span> 
</code></pre></div><p>Currently there is no way to pass around outputs, so this will not really execute. However, This non-determinsitc entry-point/s approach should work for the given program.</p>
<center><gif-player src=/images/dfp/2.gif size=contain style="width: 100%; height: 30vh;" prerender play speed=1></gif-player></center>
<p>However, if any node in the program has some unpopulated/not-connected input it will loop forever. Another major issue is the performance. To execute a full cycle we have to loop through and attempt to execute each node multiple times. Like in the above program, It happened that the execution started at the adder node causing it to loop twice until all nodes were executed. Had the execution started on the constant value node the program would&rsquo;ve executed in one iteration.</p>
<p>What about a deterministic entry-point/s approach? In which the program starts executing from multiple nodes, in no specific order also, that are known to be able to execute successfully with regards to their inputs.</p>
<p>Meaning that an <strong>entry-point node is any node that is able to execute with no connections</strong>.</p>
<p>For this approach:</p>
<ol>
<li>Loop through all nodes trying to find any node that fits the entry-point criteria and store it somewhere.</li>
<li>Loop through all entry-point nodes and attempt to execute each one.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=nx>startingNodesIds</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{}</span>
<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nodes</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>inConnections</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
    <span class=nx>startingNodesIds</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>startingNodesIds</span><span class=p>,</span> <span class=nx>n</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>
<span class=c1>// ... ..
</span><span class=c1></span><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>nodeId</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>startingNodesIds</span> <span class=p>{</span>
  <span class=nf>executeNode</span><span class=p>(</span><span class=nx>strategy</span><span class=p>,</span> <span class=nx>strategy</span><span class=p>.</span><span class=nx>Nodes</span><span class=p>[</span><span class=nx>nodeId</span><span class=p>],</span> <span class=o>&amp;</span><span class=nx>executionTable</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><center><gif-player src=/images/dfp/3.gif size=contain style="width: 100%; height: 30vh;" prerender play speed=1></gif-player></center>
<p>This however misses one critical part. The execution is stopping at the entry-point/s and is not proceeding forward to any connections going out from it.</p>
<p>To solve this, we can recursively execute the nodes:</p>
<ol>
<li>When executing a node, loop through it&rsquo;s out connections</li>
<li>For each out conneciton, find the node its connected to and attempt to execute it.</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>executeNodeRecursive</span><span class=p>(</span><span class=nx>nodes</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>node</span><span class=p>,</span> <span class=nx>n</span> <span class=nx>node</span><span class=p>.</span><span class=nx>Node</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>executed</span> <span class=o>:=</span> <span class=c1>// .. 
</span><span class=c1></span>  <span class=p>{</span>
    <span class=c1>// * Already executed, no-op
</span><span class=c1></span>    <span class=k>return</span>
  <span class=p>}</span>

  <span class=nx>inputs</span> <span class=o>:=</span> <span class=c1>// ..
</span><span class=c1></span>
  <span class=c1>// * Execute node
</span><span class=c1></span>  <span class=nx>outputs</span><span class=p>,</span> <span class=nx>executed</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>executors</span><span class=p>.</span><span class=nf>Execute</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=nx>inputs</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=c1>// * Error executing, no-op
</span><span class=c1></span>    <span class=k>return</span>
  <span class=p>}</span>

  <span class=k>if</span> <span class=nx>executed</span> <span class=p>{</span>
    <span class=c1>// * Follow node outConnections recuresively
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>outConnection</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>n</span><span class=p>.</span><span class=nx>outConnections</span> <span class=p>{</span>
      <span class=nf>executeNodeRecursive</span><span class=p>(</span><span class=nx>nodes</span><span class=p>,</span> <span class=nx>nodes</span><span class=p>[</span><span class=nx>outConnection</span><span class=p>.</span><span class=nx>nodeId</span><span class=p>])</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><center><gif-player src=/images/dfp/4.gif size=contain style="width: 100%; height: 30vh;" prerender play speed=1></gif-player></center>
<p>At this point the only thing missing is a method to populate node inputs with its connected outputs (some sort of node&rsquo;s state)</p>
<p>At the beginning I made each node handle its own state, by storing its executed flag, inputs, and outputs. and letting each node populate its outConnections node&rsquo;s inputs. But, in order to decouple the state for later usage, and to have some sort of time-travel debug-ability I decided to store the state of each cycle in a separate structure. The structure being just a simple mapping of the nodes and their outputs.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>executionTable</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>values</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>extbl</span> <span class=o>*</span><span class=nx>executionTable</span><span class=p>)</span> <span class=nf>getNodeOutputs</span><span class=p>(</span><span class=nx>nodeId</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>outputs</span> <span class=nx>values</span><span class=p>,</span> <span class=nx>executed</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nx>outputs</span><span class=p>,</span> <span class=nx>executed</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>extbl</span><span class=p>)[</span><span class=nx>nodeId</span><span class=p>];</span> <span class=nx>executed</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>outputs</span><span class=p>,</span> <span class=nx>executed</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>extbl</span> <span class=o>*</span><span class=nx>executionTable</span><span class=p>)</span> <span class=nf>setNodeOutputs</span><span class=p>(</span><span class=nx>nodeId</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>outputs</span> <span class=nx>values</span><span class=p>)</span> <span class=p>{</span>
  <span class=p>(</span><span class=o>*</span><span class=nx>extbl</span><span class=p>)[</span><span class=nx>nodeId</span><span class=p>]</span> <span class=p>=</span> <span class=nx>outputs</span>
<span class=p>}</span>
</code></pre></div><p>Now when a node is executed, it returns an output, the executor then stores that output in the cycle execution table. Similarly, when a node being executed requires an input, the executor attempts to fetch that input from the cycle execution table. This abstraction made it easier to use a functional approach for executing the programs, which I find easier to reason about in the context of concurrent or multi-threaded applications, and overall less bugs to worry about. It also allowed me to experiment with other fun ideas later on.</p>
<p align=center>
<img src=/images/dfp/7.png>
</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go>
<span class=kd>func</span> <span class=nf>executeCycle</span><span class=p>(</span><span class=nx>nodes</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>node</span><span class=p>)</span> <span class=p>(</span><span class=nx>executionTable</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// * Init an empty execution table
</span><span class=c1></span>  <span class=nx>executionTable</span> <span class=o>:=</span> <span class=nx>executionTable</span><span class=p>{}</span>

  <span class=c1>// * Find starting nodes IDs (execution starts at nodes that have no inputs required)
</span><span class=c1></span>  <span class=c1>// * e.g: constants, and producer nodes
</span><span class=c1></span>  <span class=nx>startingNodesIds</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{}</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nodes</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>inConnections</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
      <span class=nx>startingNodesIds</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>startingNodesIds</span><span class=p>,</span> <span class=nx>n</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>nodeId</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>startingNodesIds</span> <span class=p>{</span>
    <span class=nf>executeNodeRecursive</span><span class=p>(</span><span class=nx>nodes</span><span class=p>,</span> <span class=nx>nodes</span><span class=p>[</span><span class=nx>nodeId</span><span class=p>],</span> <span class=o>&amp;</span><span class=nx>executionTable</span><span class=p>)</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=nx>executionTable</span><span class=p>,</span> <span class=kc>true</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>executeNodeRecursive</span><span class=p>(</span><span class=nx>nodes</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>node</span><span class=p>,</span> <span class=nx>n</span> <span class=nx>node</span><span class=p>,</span> <span class=nx>executionTable</span> <span class=o>*</span><span class=nx>executionTable</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>executed</span> <span class=o>:=</span> <span class=nx>executionTable</span><span class=p>.</span><span class=nf>getNodeOutputs</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>id</span><span class=p>);</span> <span class=nx>executed</span> <span class=p>{</span>
    <span class=c1>// * Already executed
</span><span class=c1></span>    <span class=k>return</span>
  <span class=p>}</span>

  <span class=nx>inputs</span> <span class=o>:=</span> <span class=nx>values</span><span class=p>{}</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>inConnection</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>n</span><span class=p>.</span><span class=nx>inConnections</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>outputs</span><span class=p>,</span> <span class=nx>available</span> <span class=o>:=</span> <span class=nx>executionTable</span><span class=p>.</span><span class=nf>getNodeOutputs</span><span class=p>(</span><span class=nx>inConnection</span><span class=p>.</span><span class=nx>nodeId</span><span class=p>);</span> <span class=nx>available</span> <span class=p>{</span>
      <span class=k>if</span> <span class=nx>outputValue</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>outputs</span><span class=p>[</span><span class=nx>inConnection</span><span class=p>.</span><span class=nx>outputId</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
        <span class=nx>inputs</span><span class=p>[</span><span class=nx>inConnection</span><span class=p>.</span><span class=nx>inputId</span><span class=p>]</span> <span class=p>=</span> <span class=nx>outputValue</span>
      <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=c1>// * Inputs considered not fully populated if any dependecy output is missing from the execution table
</span><span class=c1></span>      <span class=k>return</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=c1>// * Execute node
</span><span class=c1></span>  <span class=nx>outputs</span><span class=p>,</span> <span class=nx>executed</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>executors</span><span class=p>.</span><span class=nf>Execute</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=nx>inputs</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=c1>// * Error executing
</span><span class=c1></span>    <span class=k>return</span>
  <span class=p>}</span>

  <span class=k>if</span> <span class=nx>executed</span> <span class=p>{</span>
    <span class=nx>executionTable</span><span class=p>.</span><span class=nf>setNodeOutputs</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>id</span><span class=p>,</span> <span class=nx>outputs</span><span class=p>)</span>
    <span class=c1>// * Follow node outConnections recuresively
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>outConnection</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>n</span><span class=p>.</span><span class=nx>outConnections</span> <span class=p>{</span>
      <span class=nf>executeNodeRecursive</span><span class=p>(</span><span class=nx>nodes</span><span class=p>,</span> <span class=nx>nodes</span><span class=p>[</span><span class=nx>outConnection</span><span class=p>.</span><span class=nx>nodeId</span><span class=p>],</span> <span class=nx>executionTable</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Now I can store each execution cycle table and backtrack, or move forward by providing the execution table at any point (step) in the cycle. Also, I could persist some outputs over multiple cycles if I wanted. If instead I coupled the state with each node, this would&rsquo;ve been still possible but probably painful to implement, read, and debug.</p>
<p>So far this all works fine, I implemented a fake producer that runs in its own goroutine and produces some output every N ms, pre-populating whatever it has produced as part of the node, then triggering an execution cycle every N ms.</p>
<p align=center>
<img src=/images/dfp/rs2.gif>
</p>
<p align=center>
<img src=/images/dfp/rs.gif>
</p>
<h2 id=multiple-producers>Multiple Producers<a hidden class=anchor aria-hidden=true href=#multiple-producers>#</a></h2>
<p>Since every producer runs in a separate goroutine, When it does produce if ever, is not guaranteed. I made it produce every N ms but this can change depending on the producer settings.</p>
<p>What If I wanted to have multiple producers with varying production rates? (this somewhat represent async I/O)</p>
<p>In a case where we have n producer nodes <strong>p1, p2, &mldr;, pn</strong> where for every producer <strong>p</strong> there is no path in the graph for all <strong>p1</strong> to <strong>pn</strong> to reach any other <strong>p</strong>; everything will work just fine. Since what we have is essentially multiple program&rsquo;s graphs each with its own producer.</p>
<p align=center>
<img src=/images/dfp/5.png>
</p>
<p>However, in a program graph where we have multiple producers connecting to a single node. In other words, if any two producers in the program have a path that connects them, then the program will fail to fully execute unless both producers happen to have produced and pre-populated their outputs before triggering an execution cycle. But, this is simply not guaranteed to happen, since each producer will attempt to trigger an execution as soon as it have produced. Which in turn will simply just lock and restart the execution table every time.</p>
<p align=center>
<img src=/images/dfp/6.png>
</p>
<p>For my specific use case, all I care about is that I execute the cycle with the latest produced output from each producer.</p>
<p>For example, consider that every producer is a ticker. One producer ticks every second, one ticks every minute, and another that ticks every 5 minutes, with all producers having paths to each other.</p>
<p>I want my program to execute only once it has all of the 3 necessary ticks. To do this, I made each producer store a rolling window of N ticks, calling back to trigger an execution whenever that ticks window has changed. When there is an attempt to execute while there are other producers ticks still missing, the execution does not happen but a ticks synchroniser is flagged for each producer. Once all producers in a program have ticked according to the synchroniser the execution is triggered and the synchroniser is reset.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>SafeTicksTracker</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>mu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
  <span class=nx>v</span>  <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>SafeTicksTracker</span><span class=p>)</span> <span class=nf>Init</span><span class=p>(</span><span class=nx>producerId</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
  <span class=nx>c</span><span class=p>.</span><span class=nx>v</span><span class=p>[</span><span class=nx>producerId</span><span class=p>]</span> <span class=p>=</span> <span class=kc>false</span>
  <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>SafeTicksTracker</span><span class=p>)</span> <span class=nf>Tick</span><span class=p>(</span><span class=nx>producerId</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
  <span class=nx>c</span><span class=p>.</span><span class=nx>v</span><span class=p>[</span><span class=nx>producerId</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
  <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>SafeTicksTracker</span><span class=p>)</span> <span class=nf>Reset</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
  <span class=k>for</span> <span class=nx>producerId</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>v</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nx>v</span><span class=p>[</span><span class=nx>producerId</span><span class=p>]</span> <span class=p>=</span> <span class=kc>false</span>
  <span class=p>}</span>
  <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>SafeTicksTracker</span><span class=p>)</span> <span class=nf>IsFullyTicked</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
  <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
  <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
  <span class=nx>fullyTicked</span> <span class=o>:=</span> <span class=kc>true</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ticked</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span><span class=p>.</span><span class=nx>v</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>!</span><span class=nx>ticked</span> <span class=p>{</span>
      <span class=nx>fullyTicked</span> <span class=p>=</span> <span class=kc>false</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=nx>fullyTicked</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Stop</span><span class=p>(</span><span class=nx>stopChans</span> <span class=p>[]</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>stop</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>stopChans</span> <span class=p>{</span>
    <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>s</span> <span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
      <span class=nx>s</span> <span class=o>&lt;-</span> <span class=kc>true</span>
    <span class=p>}(</span><span class=nx>stop</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Start</span><span class=p>(</span><span class=nx>nodes</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>node</span><span class=p>)</span> <span class=p>(</span><span class=nx>stopChans</span> <span class=p>[]</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>,</span> <span class=nx>ok</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>

  <span class=nx>producersStopChans</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>{}</span>
  <span class=nx>ticksTracker</span> <span class=o>:=</span> <span class=nx>SafeTicksTracker</span><span class=p>{</span><span class=nx>v</span><span class=p>:</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>{}}</span>

  <span class=c1>// * Find all producer nodes
</span><span class=c1></span>  <span class=nx>producerNodes</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>node</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>nodes</span> <span class=p>{</span>
    <span class=k>if</span> <span class=nx>n</span><span class=p>.</span><span class=nx>Type</span> <span class=o>==</span> <span class=nx>PRODUCER_NODE</span> <span class=p>{</span>
      <span class=nx>producerNodeCopy</span> <span class=o>:=</span> <span class=nx>n</span>
      <span class=nx>producerNodes</span><span class=p>[</span><span class=nx>n</span><span class=p>.</span><span class=nx>id</span><span class=p>]</span> <span class=p>=</span> <span class=nx>producerNodeCopy</span>
      <span class=nx>ticksTracker</span><span class=p>.</span><span class=nf>Init</span><span class=p>(</span><span class=nx>n</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=c1>// * Starting producers
</span><span class=c1></span>  <span class=kd>var</span> <span class=nx>nodesMapMutex</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>pn</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>producerNodes</span> <span class=p>{</span>
    <span class=c1>// * Each producer will callback to this function (from the producer goroutine context) once its dataWindow is changed and ready to be used in a an execution cycle
</span><span class=c1></span>    <span class=nx>started</span><span class=p>,</span> <span class=nx>stopChan</span> <span class=o>:=</span> <span class=nx>producer</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>pn</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>producerNodeId</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>dataWindow</span> <span class=cm>/*...*/</span><span class=p>)</span> <span class=p>{</span>
      <span class=c1>// * Updating the producer dataWindow with the newly produced data to be used in the execution cycle as outputs
</span><span class=c1></span>      <span class=c1>// * A mutex is required to prevent conncurent map writes to the nodes map as dataWindows of different producers are being updated
</span><span class=c1></span>      <span class=nx>nodesMapMutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
      <span class=nx>nodes</span><span class=p>[</span><span class=nx>producerNodeId</span><span class=p>].</span><span class=nx>AdditionalData</span><span class=p>[</span><span class=s>&#34;dataWindow&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nx>dataWindow</span>
      <span class=nx>nodesMapMutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>

      <span class=cm>/*
</span><span class=cm>      *  A concurrently safe ticks tracker is used to keep track of what producers have produced.
</span><span class=cm>      * this is implemented such that an execution cycle will only execute if all producers of that set of a program have produced
</span><span class=cm>      * the tracker is then reset to start the tracking again. So that another cycle of production is awaited from the producers
</span><span class=cm>       */</span>
      <span class=nx>ticksTracker</span><span class=p>.</span><span class=nf>Tick</span><span class=p>(</span><span class=nx>producerNodeId</span><span class=p>)</span>
      <span class=k>if</span> <span class=nx>ticksTracker</span><span class=p>.</span><span class=nf>IsFullyTicked</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>ticksTracker</span><span class=p>.</span><span class=nf>Reset</span><span class=p>()</span>
        <span class=c1>// * Cycle execution starts
</span><span class=c1></span>        <span class=c1>// * this also locks the producers from accessing the nodes map while the cycle is executing
</span><span class=c1></span>        <span class=nx>nodesMapMutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
        <span class=nf>executeCycle</span><span class=p>(</span><span class=nx>nodes</span><span class=p>)</span>
        <span class=nx>nodesMapMutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
      <span class=p>}</span>
    <span class=p>},</span> <span class=kd>func</span><span class=p>(</span><span class=nx>producerNodeId</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
      <span class=nf>Stop</span><span class=p>(</span><span class=nx>producersStopChans</span><span class=p>)</span>
    <span class=p>})</span>

    <span class=k>if</span> <span class=p>!</span><span class=nx>started</span> <span class=p>{</span>
      <span class=c1>// * If any producers failed to start for some reason, clean up by stopping all producers
</span><span class=c1></span>      <span class=nf>Stop</span><span class=p>(</span><span class=nx>producersStopChans</span><span class=p>)</span>
      <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>false</span>
    <span class=p>}</span>

    <span class=c1>// * Store producer stop channel to be used to stop the producer
</span><span class=c1></span>    <span class=nx>producersStopChans</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>producersStopChans</span><span class=p>,</span> <span class=nx>stopChan</span><span class=p>)</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=nx>producersStopChans</span><span class=p>,</span> <span class=kc>true</span>
<span class=p>}</span>
</code></pre></div><p>Since each producer runs in a goroutine, attempting to modify a shared resource (producers synchroniser) some form of locking is necessary; that is why you see the mutex in the code.</p>
<h3 id=performance-remarks>Performance Remarks<a hidden class=anchor aria-hidden=true href=#performance-remarks>#</a></h3>
<p>Why Golang? Initially, I started the project (which is still a WIP) with Python for the backend, TypeScript for the frontend. Keep In mind that although I&rsquo;m showing a simple loop producer in here. A producer can be anything, including some heavy I/O operations. So, when stress testing, Python&rsquo;s GIL stepped in. I converted my implementation to be multiprocessing which was much better. But, overhead for memory, and initial start time for each producer (e.g when I wanted to restart thousands of them) was a major bottleneck.</p>
<h3 id=zero-down-time-releases>Zero Down Time Releases?<a hidden class=anchor aria-hidden=true href=#zero-down-time-releases>#</a></h3>
<p>I&rsquo;m trying to keep the full picture of this side project a little vague here until it&rsquo;s somewhat ready 😶‍🌫️🥷🏽, So this is a little hard to explain without the full details. But anyway, the program executor above runs as scaleable microservice, which in-turn runs those visual programs indefinitely.</p>
<p>A simplified idea for a new release: I could schedule some downtime, shutdown the service with its programs. Run the new one and restart all the programs from their latest execution tables.</p>
<p>However, for this project, a restarted program will not execute accurately if you just have a missing window of data between its stop and restart. For example, a program that has some producer producing every second was stopped for 10 minutes before restarting. Now there are 600 missing produced outputs in which an execution result might depend on.</p>
<p>I solved this using a program service-to-service hand-over/migration allowing all users to still run new programs, and at the same time have already running programs moved to the newly ran service with zero down time.</p>
<p>I will show this ✨ method in another post.</p>
<p align=center>
<img src=/images/dfp/s-to-s.png>
</p>
</div>
<footer class=post-footer>
<ul class=post-tags dir=ltr>
<li><a href=https://wes4m.io/tags/dev/>dev</a></li>
<li><a href=https://wes4m.io/tags/golang/>golang</a></li>
</ul>
<nav class=paginav>
<a class=next href=https://wes4m.io/posts/epson_rev/>
<span class=title>Next »</span>
<br>
<span>Reverse engineering thermal printers</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2023 <a href=https://wes4m.io/>wes4m</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
</body>
</html>