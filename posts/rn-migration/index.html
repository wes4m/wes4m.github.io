<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Hybrid Migration: Native to React Native | wes4m</title>
<meta name=keywords content>
<meta name=description content="At Ejaro, we have been transitioning to React Native over the past two years while continuing to build new features and growing our app. Instead of undertaking a complete rewrite from scratch, we adopted a hybrid approach. This strategy has been successfully implemented by companies like Shopify and others. In this post I go over some of the decision taking approaches, challenges, and solutions we implemented.
Why Move to React Native?">
<meta name=author content="wes4m">
<link rel=canonical href=https://wes4m.io/posts/rn-migration/>
<link crossorigin=anonymous href=/assets/css/stylesheet.c266585e349dd9ce670351e0239f03ee0ebc4ca57cc47e0fd0d98f00e50aee7e.css integrity="sha256-wmZYXjSd2c5nA1HgI58D7g68TKV8xH4P0NmPAOUK7n4=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://wes4m.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://wes4m.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://wes4m.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://wes4m.io/apple-touch-icon.png>
<link rel=mask-icon href=https://wes4m.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<script src=/dist/webcomponents-loader.js></script>
<script src=/dist/gif-player.es6.js defer async></script>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-X4Z7CWYY5B"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-X4Z7CWYY5B',{anonymize_ip:!1})}</script>
<meta property="og:title" content="Hybrid Migration: Native to React Native">
<meta property="og:description" content="At Ejaro, we have been transitioning to React Native over the past two years while continuing to build new features and growing our app. Instead of undertaking a complete rewrite from scratch, we adopted a hybrid approach. This strategy has been successfully implemented by companies like Shopify and others. In this post I go over some of the decision taking approaches, challenges, and solutions we implemented.
Why Move to React Native?">
<meta property="og:type" content="article">
<meta property="og:url" content="https://wes4m.io/posts/rn-migration/">
<meta property="og:image" content="https://wes4m.io/%3Cimage%20path/url%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2025-01-21T02:47:01-07:00">
<meta property="article:modified_time" content="2025-01-21T02:47:01-07:00"><meta property="og:site_name" content="wes4m">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://wes4m.io/%3Cimage%20path/url%3E">
<meta name=twitter:title content="Hybrid Migration: Native to React Native">
<meta name=twitter:description content="At Ejaro, we have been transitioning to React Native over the past two years while continuing to build new features and growing our app. Instead of undertaking a complete rewrite from scratch, we adopted a hybrid approach. This strategy has been successfully implemented by companies like Shopify and others. In this post I go over some of the decision taking approaches, challenges, and solutions we implemented.
Why Move to React Native?">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wes4m.io/posts/"},{"@type":"ListItem","position":2,"name":"Hybrid Migration: Native to React Native","item":"https://wes4m.io/posts/rn-migration/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hybrid Migration: Native to React Native","name":"Hybrid Migration: Native to React Native","description":"At Ejaro, we have been transitioning to React Native over the past two years while continuing to build new features and growing our app. Instead of undertaking a complete rewrite from scratch, we adopted a hybrid approach. This strategy has been successfully implemented by companies like Shopify and others. In this post I go over some of the decision taking approaches, challenges, and solutions we implemented.\nWhy Move to React Native?","keywords":[],"articleBody":"At Ejaro, we have been transitioning to React Native over the past two years while continuing to build new features and growing our app. Instead of undertaking a complete rewrite from scratch, we adopted a hybrid approach. This strategy has been successfully implemented by companies like Shopify and others. In this post I go over some of the decision taking approaches, challenges, and solutions we implemented.\nWhy Move to React Native? In essence, the decision is about efficiency in time and effort, better resource allocation, streamlined hiring processes, cost savings, accelerated development speed and productivity.\nAs the backlog grows, teams find themselves building more features and addressing more issues, the codebase becomes cluttered with duct tape fixes, and “necessary” refactoring is continuously postponed, implementing new features, debugging issues, and deploying fixes all start to get harder and take longer time to do. This leads to increasing frustration among both developers and leadership. Efforts are often directed towards better prioritization, organizational improvements, and hiring to meet the growing demand. While maintaining multiple codebases for the same application is far from ideal, it often goes unchallenged. Transitioning from native development is perceived as a massive project, typically thought of as a complete rebuild, which can be dismissed as just another “refactor” project. Limited resources further exacerbate this issue, leading to the project being quickly set aside due to its seemingly low ROI, especially when considering that a full rebuild will likely take years, pulling team members away from more important tasks, working in the dark without delivering any tangible results, also often requiring a feature freeze to have a good outcome, risking an a never ending rebuild project otherwise.\nHowever, in the long run, for the majority of applications, maintaining a single cross-platform codebase with current tech is almost always a better position to be in. Keeping in mind that we can still drop to native wherever necessary. It automatically enhances various aspects, some of which:\n Faster iterations, bug fixes, and feature releases can reach users immediately through OTA updates. Lower development and maintenance costs. Easier management for monitoring and logging across technical, marketing metrics, and UX/UI tracking. Easier A/B testing processes. Can have a smaller team, and can leveraging web and full-stack developers. When planned, a significant portion of the codebase can be shared with web.  Full Rewrite vs. Gradual Migration Opting for a full rewrite can be advantageous if there are sufficient resources, and a feature freeze is a possiblity. It’s easier to think about, plan, and execute. But, understandbly many companies cannot afford to take this route. A gradual transition from native to React Native offers a more balanced solution. By integrating React Native with existing native code, we can progressively migrate to React Native over time. This involves maintaining the native codebase while incrementally replacing one screen, view, or flow at a time, then delivering that to production quickly. Simultaneously, any new features can be developed in React Native until the entire application is fully transitioned.\nCompared to a full rewrite, a gradual migration will get new React Native code in the hands of real users sooner, enabling us to identify and address issues, and solutions earlier in the process. It also integrates the rebuild as part of the regular development cycle, allowing continuous iteration as we migrate. It avoids the chaos of a complete overhaul and lets us manage changes more smoothly, avoiding ending up shipping a tangled mess of code that is probably out of sync with the requirements by the time it’s completed.\nI reached out to the awesome folks at Infinite Red and they shared many great points, some take aways about making this decision:\n Size and Value of the App: For large, high-value applications, a gradual migration is often the best approach. It allows for a smooth transition without disrupting the entire system. Smaller apps might benefit more from a complete rewrite, which can be faster and involve fewer complications. Team and Resource Management: Successful migration requires the right team structure and adequate resources. You need to think about your current team ability, comfortability and expertise with native and react native, and to think about wether you will hire more engineers for the project or not. They also found that teams that were discplined with their feature freezs during full rewrite migrations were more successful in the process. Handling Complexities: Migrating a large app requires careful planning and incremental changes. Gradual migration is likely to be more complex and have more issues.  Overall, the right approach depends on your app’s complexity, the resources available, and the importance of maintaining stability during the transition. Gradual migration might be generally safer for larger, more complex apps, while a full rewrite might be suitable for smaller projects with fewer dependencies.\nHow Does It Work React Native supplies the essential native primitives—such as ViewController on iOS, Fragment, Activity on Android —to load and render RN’s JavaScript bundle. This allows us to integrate a React Native root view controller into the existing native navigation stack. The end goal is to have a navigation stack that seamlessly accommodates both React Native and native screens. For instance, in a simplified rentals application it might look like the following:\nHowever, depending on how the code and navigation are structured. This will introduce various complexities and challenges to tackle.\nSetup Many React Native startes and boilerplates conveniently include both Android and iOS projects setup/folders, providing an excellent foundation to begin with. We found that Expo is a little harder to get setup into an existing app compared to bare React Native.\nGetting React Native into an existing codebase can be a tedious process depending on the age and structure of the existing codebase. But, with determination, tens of rebuilds, cache invalidations, and node_modules deletions. The app will eventually, hopefully, start running.\nHere’s how we approached it:\n  Combining Repositories: We started by copying our separate Android and iOS repositories and removing any Git-related files. Then, we embedded them into a new React Native app repository by replacing the existing androidand ios folders.\n  Adding Dependencies and Configurations: Step by step, we modified the projects to include the necessary React Native pods, merging the podfiles, packages, and configurations. At this stage, we didn’t add any functionality through React Native app code. Our main goal was to ensure that both the Android and iOS projects had all the required dependencies and setup from React Native while running normally without any issues or degradations.\n  Laying the Ground Work: Once the setup was working, we began implementing classes responsible for handling navigation, state sharing, and other bridge methods that we’ll discuss later. Importantly, we didn’t replace the native app entry points with React Native at this point. Instead, we kept that native and only initialized the React Native bundle to be used later in the migration process.  Navigation One of the initial challenges we encountered is how React Native manages navigation. While our goal is to achieve the seamless stack described earlier, React Native maintains its own navigation stack, which typically appears more like the stack below in which a shared instance of React Native root view controller holds your react app.\nFor instance, consider you have somehow reached the Receipt screen while managing your navigation stack with React Navigation.\nWhen the user attempts to go back, the shared RNRootViewController rendering your react app does not know anything about the state of the native navigation stack. Consequently, it navigates back to the search screen instead of the intended previous screen. This occurs because React Native’s controller operates within its own navigation context, unaware of the native view controllers.\nOne potential approach is to instantiate a new RNRootViewController or reset React Native’s navigation stack each time a navigation crosses the React Native  native boundary.\nHowever, other than the overhead of creating a new container with every transition—which might be an acceptable overhead until the app is fully migrated to React Native—there is an additional issue. From the Receipt screen’s perspective, there are no previous screens to navigate back to. It’s the first thing in the stack.\nA straightforward solution is to leverage React Native-to-native bridges. By implementing a unified “go back” method within React Native, we can ensure that if there are no screens to navigate back to in React Native’s stack, the method delegates the navigation control back to the native layer. This allows the navigation controller in native to handle the navigation, returning to the previous native screen seamlessly if there is any.\nOther options, such as Wix’s React Native Navigation are also available. However, we found that this solution only works effectively if the app’s native architecture is already structured in alignment with the framework’s design. If the native codebase doesn’t fit, it is generally more advantageous to manage navigation through a custom implementation. I think that the available native navigation packages are beneficial for new applications that are designed from the beginning with a hybrid future in mind, not for a brownfield app being converted to hybrid. Folks at Infinite Red, also shared some great tips on handling navigation between native and React Native parts of the app. They mentioned that navigation was indeed one of the main challenges in similar projects they worked on. To make it smoother, they suggest thinking about and building the navigation stack so that it moves from native to native to React Native, instead of mixing it up like native  RN  native. Thinking of navigation in terms of user flows rather than single screens to minimze crossing the boundary and thus lowering navigation complexity. This will lead to some screens/flows taking longer to release, as other related screens need to be completed and packaged first as a complete flow.\nKeeping related screens together makes the flow feel more natural and easier to handle. We’ve done somthing similar at Ejaro which have definitely made handling navigation less of a hassle. They also recommend starting small by migrating the most static screens first—those that don’t rely heavily on native modules. This way, the focus can be on getting the navigation right without getting bogged down by other complexities.\nAs more screens get transitioned, eventually we needed to update our Home Screens. We use a native bottom tab bar navigator, which initially looked like this:\nWe found it’s best to keep the tab bar in native until the very end. Once all of the screens are transitioned to React Native, we switched the tab bar to React Native as well. The team at Infinite.red also agrees with this strategy.\nNavigation here can follow four main paths:\n React Native to Native Native to React Native Native to Native React Native to React Native  Paths 3 and 4 are generally straightforward. Nothing needs to be changed on either native or react native side. However, paths 1 and 2 can be a bit tricky because screens often rely on specific states or parameters to function correctly. For example, in the rentals app, you might need a rental id, dates, or other important details to be passed to a rental summary screen.\nTo tackle the first scenario—navigating from React Native to native—we decided to transition screens in a way that minimizes cases where we have to take this path (1). Then implemented a bridge method that handles each screen manually for cases where we needed it. This approach ensures that each transition is managed properly.\nfunc navigate(screenIdentifier: String, data: [String: Any], ....)  I didn’t have enough time to fully explore other approaches. However, I started initial work on a package to handle hybrid navigation seamlessly. The main idea is was decorate or extend any native ViewController, Fragment, or Activity to make them accessible from React Native. By using a code generator (e.g Sourcery for Swift) to automate the routing and parameter passing required for each screen. I might release this package later if I ever get to back to completing it.\n The second navigation path—moving from native to React Native—is naturally more common, since the app is already built entirely in native. We were comfortable with the overhead of creating a new container for each screen, as we found that it had negligible impact on performance and responsiveness.\nTo handle this transition smoothly, we implemented our React app’s entry point logic using React Navigation with a setup that allows us to accept initial parameters, including the target screen and other state details. These parameters are passed during the creation of the RCTRootView by setting them as initialProperties on the native side.\nconst AppStack = ({ initialRoute, initialState, }: { initialRoute?: keyof AppStackParamList initialState?: InitialStateProps }) = { /** * * State changes with navigational effects can be observed here */ /** * InitialRoute and InitialState here come from the native side when a component is requested with initialProps * This allows selecting which screen to show without registering all of them, thus keeping the stack navigation intact * This also passes the data to the screen through initialParams */ return ( Stack.Navigator screenOptions={{ headerShown: false, fullScreenGestureEnabled: true, customAnimationOnGesture: true, }} initialRouteName={initialRoute} Stack.Screen name=\"Index\" initialParams={{...initialState}} component={BottomTabs} / ... ... ... Deep linking is another crucial part of our app. We decided to continue managing deep links on the native side since now we need to direct users to either native or React Native screens. By using the same setup, we navigate using a manual check. and trigger the navigation for react native side entry point to handle. We make sure that the React Native bundle is ready before that.\nAs we began transitioning some of our home screens—those managed by the native tab bar navigator—we ran into a few issues which we think can be common in this process:\n  Eager Loading of Tab Screens: On iOS, the tab bar navigator eagerly loads each tab’s RCTRootView. This can cause some unwanted side effects by rendering each tab screen in the background.\nTo tackle this, we explored a few different approaches:\n Disabling Eager Loading: We thought about turning off eager loading and creating the container only when navigating to each tab. While this reduces unnecessary background rendering, it comes with its own set of problems. We end up losing the previous state, such as scroll position, and filled fields whenever users switch between tabs. Plus, it triggers a full re-render every time, which isn’t ideal. Managing Background Rendering: Another option we considered was anticipating and designing for background rendering on the React Native side. But this also is not ideal. Using View/Activity Life Cycle events: This involves setting up the right triggers and managing view lifecycle events between the native and React Native root view controllers along with disabling eager loading. However, this time keeping the first created container instead of making a new one.    Persistent Native Tab Bar: We noticed that when navigating from a tab screen to another React Native screen within the same container, the native bottom tab bar stays visible across all screens. This creates a similar issue to before, where the React Native controller doesn’t have context about the native navigation stack.\n  On the search screen, the bottom tab bar shouldn’t be visible—it needs to be hidden. One option we considered was having the native side create a new React root view controller for the search screen and push it to the native navigation stack. However, this felt a bit convoluted since it involves switching back and forth between React Native and native layers.\nInstead, we opted for a simpler solution. We created a list of screens where the bottom tab bar should be displayed, which is only the four main screens. Alongside this, we implemented a native method to control the visibility of the bottom bar. With this setup, when navigating within React Native, we check if the screen we’re moving to is on our list. If it is, we show the bottom bar; if not, we hide it by calling the bridge method.\n Double Navigation Headers: On iOS, we used the built-in navigation header with some customizations. When adding headers in React Native screens and navigating from native, two headers would appear—one native and one React Native.\nTo fix this, we hid and showed the headers whenever we crossed the boundry between native and react native. This is done by using our existing navigation methods.\n  Infinite Nested Navigations: On both the native and React Native, the default behaviour when trying to navigate to the same screen or one that’s already in the stack is to not add a new instance, which is great. However, with our setup, navigating between Native  RN  Native  RN  Native could lead to multiple instances of the same screen being added to the stack. While we minimized this by planning our screen transitions in a flow-like manner, it can still happen. To solve this and a few other issues, such as showing a force update screen without duplication, we kept track of the currently displayed screen and whether it’s managed by native or React Native. This allowed us to manage the navigation behavior correctly and prevent unnecessary screen duplications.\n  Navigation Controllers: This wasn’t a concern on Android, but for iOS, we had to keep track of the last navigation controller used. This way, we knew which stack to push the RCTRootView onto when needed. This was a side effect of how our native codebase and navigation were structured, but it’s an important detail to mention.\n  Modals, Present, Push, StartActivity, etc.: There are a few other nuances to handle since both iOS and Android have different types of navigations, like presenting a modal on iOS. We managed these similarly to our standard navigation by keeping track of the presentation method. This helped us properly dismiss modals using our bridged unified “go back” method.\n  It’s also a good idea to have a the RCTBridge instance be shared and reused in all RCTRootViews to avoid unnecessarily reloading the bundle. Along with initalizing an empty RCTRootView at native app start to avoid delays for first renders. We have a simple bundle init setup looking like this in IOS side with CodePush as our OTA updates provider.\nprivate override init() { super.init() #if DEBUG let jsBundleURL = RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: \"index\", fallbackExtension: nil) #else let jsBundleURL = CodePush.bundleURL() #endif self.bridge = RCTBridge(bundleURL: jsBundleURL, moduleProvider: nil, launchOptions: nil) } Notifications We’re already managing notifications on the native side—which we need to keep there—we also need to handle them in React Native. For example, this allows us to refresh a screen or perform other actions when a notification is received. We addressed this by emitting events from the native to React Native (React Native Communication) whenever we get a notification, with the goal of eventually moving all notification handling to React Native. Of course, this approach doesn’t give us full control over notification handling since we’re not directly influencing how notifications are managed. However, it serves as a temporary solution that meets our current use cases effectively.\nNote: To save yourself time and frustration, always test notifications on physical devices. Simulators often have numerous issues and inconsistencies, regardless of what Apple and Google’s documentation suggests.\nState Sharing Starting with a native app means that all stored state resides in the native layer. This setup creates two separate places where the state can be modified. For example, if authentication is handled natively, the session is stored and used by the native API manager. However, any authenticated React Native screen isn’t aware of the native session, and vice versa. To address this, we need a shared state between the two sides.\nThere are several ways to approach this. We can use additional bridge methods or emit events to synchronize the state between native and React Native. This is the same strategy recommended by experts at Infinite.red. Since this is a critical part of our app and the interface between the two sides lacks static type checking or code generation (There is Nitro now), we suggest implementing strict runtime type checking using tools like Zod and adding tests to catch any issues early in development. Our goal is to eventually transition fully to React Native as more responsibilities shift there over time. Therefore, designing the state with this eventual move in mind is the approach we followed.\nWe also stored some of the state locally on the device for both native and React Native, using UserDefaults on iOS for example. For these states, we directly access and modify them with packages such as react-native-default-preference.\nExtra Android Activity vs Fragments React Native documentation uses Activities as the primary method for integrating with existing applications. This approach is generally easier to implement and encounters fewer initial issues. However, it was harder to manage later on. The alternative is to use Fragments. Depending on the codebase, wrapping React fragments within a native activity might not be straightforward. Despite this, we found that using the Fragments greatly improved our workflow when embedding React screens in various parts of the native Android app, such as the bottom tab bar navigator.\nRTL Issues Our app supports both Arabic and English, with Arabic being a right-to-left (RTL) language. Getting RTL to work turned out to be quite challenging with this setup. We tried several solutions, but iOS wouldn’t change the RTL direction after rendering, and React Native seemed to have the same issue. In the end, we decided to have the native side update the RTL direction whenever the language changes and then reload the React Native bundle, effectively restarting the app.\nGestures and Swipe to Go Back We needed to handle/override the native go back and swipe to go back events when navigating between native and React Native to makesure swiping works within React Native stack context, not to trigger a full RCTRootView to be swiped back unless the stack has nothing further to go back to.\nProtected Screens Depending on the setup, some authentication checks will need to be performed manually rather than being managed by the navigator itself. This wasn’t a big deal for us, as we mainly encountered it during the period when we had both native and React Native screens in the bottom tab bar at the same time.\nKeyboad Avoid Issues This isn’t specific to migration, but if you’re taking the hybrid route, you’re likely not using Expo from the start. That means you’ll need to handle keyboard avoiding views manually. This turned out to be a major challenge due to the differences in behavior between Android and iOS, especially with bottom sheets.\nThe only approach that worked for us was setting android:windowSoftInputMode=\"adjustPan\" on our React container for Android and handling KeyboardAvoidingView behavior with: Platform.OS === 'ios' ? 'padding' : undefined. Along with using keyboard show/hide events where necessary.\nAnother promising solution we haven’t explored yet is react-native-keyboard-controller. Additionally, Expo’sdocumentation on keyboard handling is a useful resource.\nTimeline and Metrics  Initial discussions \u0026 research: August 14, 2023 First commit: Sep 25, 2023 Major scaffolding and shell setup done: Sept 28, 2023 First Internal build with React Native shipped for testing: October 28, 2023 First build with React Native shipped to production: May 27, 2024 Full migration to React Native: Feb 10, 2025  Frequency of releases before and after shipping React Native Number of internal builds sent for testing before and after shipping React Native This serves as a useful metric that can indirectly reflect the amount of testing and rebuilding needed for native modifications compared to React Native, which tends to slow down the development cycle.\nContributions before and after shipping React Native Both the number of team contributors to the app and the volume of additions have increased.\nAreas for Improvement You may notice that there was a considerable amount of time between our first commit and the first production release. However, this timeline and outcome was still better for us than completing a full rewrite. By our first react native code release, we had already released numerous internal builds to the team for testing. We had completed many major screens, flows, and many smaller ones, along with implementing state sharing, navigation, payments, monitoring, and other key aspects of the app. We believe this should and could have been accomplished much earlier, with smaller more frequent releases. However, the flows we initially chose to transition included numerous native modules and were not the most effective starting points for delivering this to users quickly. This shows how crucial it is to take the time to plan and research for a project like this. We recommend truly understanding your app flows and coming up with a plan according to previous suggestions with the intention of getting this to your users sooner.\nWe also focused most of our efforts in getting IOS working smoothly, resulting in Android being somewhat neglected. This situation is partly due to our small team managing multiple large projects simultaneously. Naturally, this challenge extends beyond just migration. We should approach each project by considering both platforms from the start, and continuously planning for both. We recommend giving more thought to both platforms when planning the migration. This also ties into the previous point of understanding your app’s workflows and deciding which ones to prioritize first for the transition. Sometimes, depending on your codebase, a workflow that makes sense to start with on iOS might become challenging to implement on Android, or the other way around. When deciding on a flow or a screen you need to consider it on both platforms.\nConclusion Migrating from a native codebase to React Native was both challenging and rewarding for us. Now, every engineer on our team can handle tasks from requirements gathering to initiating planning and implementation across both the backend and frontend, embracing a true full-stack approach. This migration has granted us greater flexibility, increased our productivity, collaboration, shipping speed all while reducing the cognitive load of every fix and feature implementation.\nResources Nearform’s multi-part guide is particularly valuable, as it thoroughly addresses many of the challenges we faced and offers in great detail effective approaches and solutions. I unfortunately only found it while writing this post. I think it’s a must read for anyone planning to go through the migration.\n Strangler Fig Pattern for Mobile Apps React Native - Integration with Existing Apps Nearform - Adding React Native to a Complex App Callstack - Migration to React Native Agile engine - Migrate to React Native Shopify - Migrating Our Largest Mobile App to React Native Walmart labs - Electrode  Thanks A huge thank you to the team at Ejaro for their amazing work, and Omar Bahareth for his support and guidance.\nThanks a lot to Jamon, as well as everyone at Infinite Red for their invaluable insights.\n","wordCount":"4444","inLanguage":"en","image":"https://wes4m.io/%3Cimage%20path/url%3E","datePublished":"2025-01-21T02:47:01-07:00","dateModified":"2025-01-21T02:47:01-07:00","author":{"@type":"Person","name":"wes4m"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wes4m.io/posts/rn-migration/"},"publisher":{"@type":"Organization","name":"wes4m","logo":{"@type":"ImageObject","url":"https://wes4m.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://wes4m.io/ accesskey=h title="./ (Alt + H)">./</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://wes4m.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://wes4m.io/>Home</a>&nbsp;»&nbsp;<a href=https://wes4m.io/posts/>Posts</a></div>
<h1 class=post-title dir=ltr>
Hybrid Migration: Native to React Native
</h1>
<div class=post-meta dir=ltr><span title="2025-01-21 02:47:01 -0700 -0700">January 21, 2025</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;wes4m&nbsp;|&nbsp;<a href=https://github.com/wes4m/wes4m.github.io/tree/drafting/content/posts/rn-migration.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content dir=ltr><p>At <a href=https://github.com/Ejaro>Ejaro</a>, we have been transitioning to React Native over the past two years while continuing to build new features and growing our app. Instead of undertaking a complete rewrite from scratch, we adopted a hybrid approach. This strategy has been successfully implemented by companies like <a href=https://shopify.engineering/migrating-our-largest-mobile-app-to-react-native>Shopify</a> and others. In this post I go over some of the decision taking approaches, challenges, and solutions we implemented.</p>
<h2 id=why-move-to-react-native>Why Move to React Native?<a hidden class=anchor aria-hidden=true href=#why-move-to-react-native>#</a></h2>
<p>In essence, the decision is about efficiency in time and effort, better resource allocation, streamlined hiring processes, cost savings, accelerated development speed and productivity.</p>
<p>As the backlog grows, teams find themselves building more features and addressing more issues, the codebase becomes cluttered with duct tape fixes, and &ldquo;necessary&rdquo; refactoring is continuously postponed, implementing new features, debugging issues, and deploying fixes all start to get harder and take longer time to do. This leads to increasing frustration among both developers and leadership. Efforts are often directed towards better prioritization, organizational improvements, and hiring to meet the growing demand. While maintaining multiple codebases for the same application is far from ideal, it often goes unchallenged. Transitioning from native development is perceived as a massive project, typically thought of as a complete rebuild, which can be dismissed as just another &ldquo;refactor&rdquo; project. Limited resources further exacerbate this issue, leading to the project being quickly set aside due to its seemingly low ROI, especially when considering that a full rebuild will likely take years, pulling team members away from more important tasks, working in the dark without delivering any tangible results, also often requiring a feature freeze to have a good outcome, risking an a never ending rebuild project otherwise.</p>
<p>However, in the long run, for the majority of applications, maintaining a single cross-platform codebase with current tech is almost always a better position to be in. Keeping in mind that we can still drop to native wherever necessary. It automatically enhances various aspects, some of which:</p>
<ul>
<li>Faster iterations, bug fixes, and feature releases can reach users immediately through OTA updates.</li>
<li>Lower development and maintenance costs.</li>
<li>Easier management for monitoring and logging across technical, marketing metrics, and UX/UI tracking.</li>
<li>Easier A/B testing processes.</li>
<li>Can have a smaller team, and can leveraging web and full-stack developers.</li>
<li>When planned, a significant portion of the codebase can be shared with web.</li>
</ul>
<h2 id=full-rewrite-vs-gradual-migration>Full Rewrite vs. Gradual Migration<a hidden class=anchor aria-hidden=true href=#full-rewrite-vs-gradual-migration>#</a></h2>
<p>Opting for a full rewrite can be advantageous if there are sufficient resources, and a feature freeze is a possiblity. It&rsquo;s easier to think about, plan, and execute. But, understandbly many companies cannot afford to take this route. A gradual transition from native to React Native offers a more balanced solution. By integrating React Native with existing native code, we can progressively migrate to React Native over time. This involves maintaining the native codebase while incrementally replacing one screen, view, or flow at a time, then delivering that to production quickly. Simultaneously, any new features can be developed in React Native until the entire application is fully transitioned.</p>
<p>Compared to a full rewrite, a gradual migration will get new React Native code in the hands of real users sooner, enabling us to identify and address issues, and solutions earlier in the process. It also integrates the rebuild as part of the regular development cycle, allowing continuous iteration as we migrate. It avoids the chaos of a complete overhaul and lets us manage changes more smoothly, avoiding ending up shipping a tangled mess of code that is probably out of sync with the requirements by the time it&rsquo;s completed.</p>
<p>I reached out to the awesome folks at <a href=https://infinite.red>Infinite Red</a> and they shared many great points, some take aways about making this decision:</p>
<ul>
<li><strong>Size and Value of the App</strong>: For large, high-value applications, a gradual migration is often the best approach. It allows for a smooth transition without disrupting the entire system. Smaller apps might benefit more from a complete rewrite, which can be faster and involve fewer complications.</li>
<li><strong>Team and Resource Management</strong>: Successful migration requires the right team structure and adequate resources. You need to think about your current team ability, comfortability and expertise with native and react native, and to think about wether you will hire more engineers for the project or not. They also found that teams that were discplined with their feature freezs during full rewrite migrations were more successful in the process.</li>
<li><strong>Handling Complexities</strong>: Migrating a large app requires careful planning and incremental changes. Gradual migration is likely to be more complex and have more issues.</li>
</ul>
<p>Overall, the right approach depends on your app’s complexity, the resources available, and the importance of maintaining stability during the transition. Gradual migration might be generally safer for larger, more complex apps, while a full rewrite might be suitable for smaller projects with fewer dependencies.</p>
<h2 id=how-does-it-work>How Does It Work<a hidden class=anchor aria-hidden=true href=#how-does-it-work>#</a></h2>
<p>React Native supplies the essential native primitives—such as <code>ViewController</code> on iOS, <code>Fragment</code>, <code>Activity</code> on Android —to load and render RN&rsquo;s JavaScript bundle. This allows us to integrate a React Native root view controller into the existing native navigation stack. The end goal is to have a navigation stack that seamlessly accommodates both React Native and native screens. For instance, in a simplified rentals application it might look like the following:</p>
<p align=center>
<img src=/images/rn-migration/image-20250107115058621.png>
</p>
<p>However, depending on how the code and navigation are structured. This will introduce various complexities and challenges to tackle.</p>
<h2 id=setup>Setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h2>
<p>Many React Native startes and boilerplates conveniently include both Android and iOS projects setup/folders, providing an excellent foundation to begin with. We found that Expo is a little harder to get setup into an existing app compared to bare React Native.</p>
<p>Getting React Native into an existing codebase can be a tedious process depending on the age and structure of the existing codebase. But, with determination, tens of rebuilds, cache invalidations, and node_modules deletions. The app will eventually, hopefully, start running.</p>
<p>Here’s how we approached it:</p>
<ol>
<li>
<p><strong>Combining Repositories</strong>: We started by copying our separate Android and iOS repositories and removing any Git-related files. Then, we embedded them into a new React Native app repository by replacing the existing <code>android</code>and <code>ios</code> folders.</p>
</li>
<li>
<p><strong>Adding Dependencies and Configurations</strong>: Step by step, we modified the projects to include the necessary React Native pods, merging the podfiles, packages, and configurations. At this stage, we didn’t add any functionality through React Native app code. Our main goal was to ensure that both the Android and iOS projects had all the required dependencies and setup from React Native while running normally without any issues or degradations.</p>
</li>
</ol>
<p align=center>
<img src=/images/rn-migration/image-20250107205301135.png>
</p>
<ol start=3>
<li><strong>Laying the Ground Work</strong>: Once the setup was working, we began implementing classes responsible for handling navigation, state sharing, and other bridge methods that we’ll discuss later. Importantly, we didn’t replace the native app entry points with React Native at this point. Instead, we kept that native and only initialized the React Native bundle to be used later in the migration process.</li>
</ol>
<h2 id=navigation>Navigation<a hidden class=anchor aria-hidden=true href=#navigation>#</a></h2>
<p>One of the initial challenges we encountered is how React Native manages navigation. While our goal is to achieve the seamless stack described earlier, React Native maintains its own navigation stack, which typically appears more like the stack below in which a shared instance of React Native root view controller holds your react app.</p>
<p align=center>
<img src=/images/rn-migration/image-20250107115945768.png>
</p>
<p>For instance, consider you have somehow reached the Receipt screen while managing your navigation stack with <a href=https://reactnavigation.org/>React Navigation</a>.</p>
<p>When the user attempts to go back, the shared <code>RNRootViewController</code> rendering your react app does not know anything about the state of the native navigation stack. Consequently, it navigates back to the search screen instead of the intended previous screen. This occurs because React Native&rsquo;s controller operates within its own navigation context, unaware of the native view controllers.</p>
<p align=center>
<img src=/images/rn-migration/image-20250107121427850.png>
</p>
<p>One potential approach is to instantiate a new <code>RNRootViewController</code> or reset React Native&rsquo;s navigation stack each time a navigation crosses the React Native &lt;-> native boundary.</p>
<p>However, other than the overhead of creating a new container with every transition—which might be an acceptable overhead until the app is fully migrated to React Native—there is an additional issue. From the Receipt screen&rsquo;s perspective, there are no previous screens to navigate back to. It&rsquo;s the first thing in the stack.</p>
<p align=center>
<img src=/images/rn-migration/image-20250107121804156.png>
</p>
<p>A straightforward solution is to leverage React Native-to-native bridges. By implementing a unified &ldquo;go back&rdquo; method within React Native, we can ensure that if there are no screens to navigate back to in React Native&rsquo;s stack, the method delegates the navigation control back to the native layer. This allows the navigation controller in native to handle the navigation, returning to the previous native screen seamlessly if there is any.</p>
<p>Other options, such as <a href=https://github.com/wix/react-native-navigation>Wix’s React Native Navigation</a> are also available. However, we found that this solution only works effectively if the app’s native architecture is already structured in alignment with the framework’s design. If the native codebase doesn’t fit, it is generally more advantageous to manage navigation through a custom implementation. I think that the available native navigation packages are beneficial for new applications that are designed from the beginning with a hybrid future in mind, not for a brownfield app being converted to hybrid. Folks at <a href=https://infinite.red>Infinite Red</a>, also shared some great tips on handling navigation between native and React Native parts of the app. They mentioned that navigation was indeed one of the main challenges in similar projects they worked on. To make it smoother, they suggest thinking about and building the navigation stack so that it moves from native to native to React Native, instead of mixing it up like native > RN > native. Thinking of navigation in terms of user flows rather than single screens to minimze crossing the boundary and thus lowering navigation complexity. This will lead to some screens/flows taking longer to release, as other related screens need to be completed and packaged first as a complete flow.</p>
<p align=center>
<img src=/images/rn-migration/image-20250107155424283.png>
</p>
<p>Keeping related screens together makes the flow feel more natural and easier to handle. We&rsquo;ve done somthing similar at Ejaro which have definitely made handling navigation less of a hassle. They also recommend starting small by migrating the most static screens first—those that don’t rely heavily on native modules. This way, the focus can be on getting the navigation right without getting bogged down by other complexities.</p>
<p>As more screens get transitioned, eventually we needed to update our Home Screens. We use a native bottom tab bar navigator, which initially looked like this:</p>
<p align=center>
<img src=/images/rn-migration/image-20250107162323639.png>
</p>
<p>We found it’s best to keep the tab bar in native until the very end. Once all of the screens are transitioned to React Native, we switched the tab bar to React Native as well. The team at Infinite.red also agrees with this strategy.</p>
<p>Navigation here can follow four main paths:</p>
<ol>
<li><strong>React Native to Native</strong></li>
<li><strong>Native to React Native</strong></li>
<li><strong>Native to Native</strong></li>
<li><strong>React Native to React Native</strong></li>
</ol>
<p>Paths 3 and 4 are generally straightforward. Nothing needs to be changed on either native or react native side. However, paths 1 and 2 can be a bit tricky because screens often rely on specific states or parameters to function correctly. For example, in the rentals app, you might need a rental id, dates, or other important details to be passed to a rental summary screen.</p>
<p>To tackle the first scenario—navigating from React Native to native—we decided to transition screens in a way that minimizes cases where we have to take this path (1). Then implemented a bridge method that handles each screen manually for cases where we needed it. This approach ensures that each transition is managed properly.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=kd>func</span> <span class=nf>navigate</span><span class=p>(</span><span class=n>screenIdentifier</span><span class=p>:</span> <span class=nb>String</span><span class=p>,</span> <span class=n>data</span><span class=p>:</span> <span class=p>[</span><span class=nb>String</span><span class=p>:</span> <span class=nb>Any</span><span class=p>],</span> <span class=p>....)</span>
</code></pre></div><blockquote>
<p>I didn&rsquo;t have enough time to fully explore other approaches. However, I started initial work on a package to handle hybrid navigation seamlessly. The main idea is was decorate or extend any native <code>ViewController</code>, <code>Fragment</code>, or <code>Activity</code> to make them accessible from React Native. By using a code generator (e.g Sourcery for Swift) to automate the routing and parameter passing required for each screen. I might release this package later if I ever get to back to completing it.</p>
</blockquote>
<p>The second navigation path—moving from native to React Native—is naturally more common, since the app is already built entirely in native. We were comfortable with the overhead of creating a new container for each screen, as we found that it had negligible impact on performance and responsiveness.</p>
<p>To handle this transition smoothly, we implemented our React app’s entry point logic using <a href=http://reactnavigation.org/>React Navigation</a> with a setup that allows us to accept initial parameters, including the target screen and other state details. These parameters are passed during the creation of the <code>RCTRootView</code> by setting them as <code>initialProperties</code> on the native side.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=kr>const</span> <span class=nx>AppStack</span> <span class=o>=</span> <span class=p>({</span>
  <span class=nx>initialRoute</span><span class=p>,</span>
  <span class=nx>initialState</span><span class=p>,</span>
<span class=p>}</span><span class=o>:</span> <span class=p>{</span>
  <span class=nx>initialRoute</span><span class=o>?:</span> <span class=nx>keyof</span> <span class=nx>AppStackParamList</span>
  <span class=nx>initialState</span><span class=o>?:</span> <span class=nx>InitialStateProps</span>
<span class=p>})</span> <span class=p>=&gt;</span> <span class=p>{</span>
  <span class=cm>/**
</span><span class=cm>   *
</span><span class=cm>   * State changes with navigational effects can be observed here
</span><span class=cm>   */</span>

  <span class=cm>/**
</span><span class=cm>   * InitialRoute and InitialState here come from the native side when a component is requested with initialProps
</span><span class=cm>   * This allows selecting which screen to show without registering all of them, thus keeping the stack navigation intact
</span><span class=cm>   * This also passes the data to the screen through initialParams
</span><span class=cm>   */</span>
  <span class=k>return</span> <span class=p>(</span>
    <span class=p>&lt;</span><span class=nt>Stack.Navigator</span>
      <span class=na>screenOptions</span><span class=o>=</span><span class=p>{{</span>
        <span class=nx>headerShown</span><span class=o>:</span> <span class=kc>false</span><span class=p>,</span>
        <span class=nx>fullScreenGestureEnabled</span><span class=o>:</span> <span class=kc>true</span><span class=p>,</span>
        <span class=nx>customAnimationOnGesture</span><span class=o>:</span> <span class=kc>true</span><span class=p>,</span>
      <span class=p>}}</span>
      <span class=na>initialRouteName</span><span class=o>=</span><span class=p>{</span><span class=nx>initialRoute</span><span class=p>}&gt;</span>
      <span class=p>&lt;</span><span class=nt>Stack.Screen</span> <span class=na>name</span><span class=o>=</span><span class=s>&#34;Index&#34;</span> <span class=na>initialParams</span><span class=o>=</span><span class=p>{{...</span><span class=nx>initialState</span><span class=p>}}</span> <span class=na>component</span><span class=o>=</span><span class=p>{</span><span class=nx>BottomTabs</span><span class=p>}</span> <span class=p>/&gt;</span>
      <span class=p>...</span>
      <span class=p>...</span>
      <span class=p>...</span>
</code></pre></div><p>Deep linking is another crucial part of our app. We decided to continue managing deep links on the native side since now we need to direct users to either native or React Native screens. By using the same setup, we navigate using a manual check. and trigger the navigation for react native side entry point to handle. We make sure that the React Native bundle is ready before that.</p>
<p>As we began transitioning some of our home screens—those managed by the native tab bar navigator—we ran into a few issues which we think can be common in this process:</p>
<ol>
<li>
<p><strong>Eager Loading of Tab Screens</strong>: On iOS, the tab bar navigator eagerly loads each tab’s <code>RCTRootView</code>. This can cause some unwanted side effects by rendering each tab screen in the background.</p>
<p>To tackle this, we explored a few different approaches:</p>
<ul>
<li><strong>Disabling Eager Loading</strong>: We thought about turning off eager loading and creating the container only when navigating to each tab. While this reduces unnecessary background rendering, it comes with its own set of problems. We end up losing the previous state, such as scroll position, and filled fields whenever users switch between tabs. Plus, it triggers a full re-render every time, which isn&rsquo;t ideal.</li>
<li><strong>Managing Background Rendering</strong>: Another option we considered was anticipating and designing for background rendering on the React Native side. But this also is not ideal.</li>
<li><strong>Using View/Activity Life Cycle events:</strong> This involves setting up the right triggers and managing view lifecycle events between the native and React Native root view controllers along with disabling eager loading. However, this time keeping the first created container instead of making a new one.</li>
</ul>
</li>
<li>
<p><strong>Persistent Native Tab Bar</strong>: We noticed that when navigating from a tab screen to another React Native screen within the same container, the native bottom tab bar stays visible across all screens. This creates a similar issue to before, where the React Native controller doesn&rsquo;t have context about the native navigation stack.</p>
</li>
</ol>
<p align=center>
<img src=/images/rn-migration/image-20250107184825284.png>
</p>
<p>On the search screen, the bottom tab bar shouldn’t be visible—it needs to be hidden. One option we considered was having the native side create a new React root view controller for the search screen and push it to the native navigation stack. However, this felt a bit convoluted since it involves switching back and forth between React Native and native layers.</p>
<p>Instead, we opted for a simpler solution. We created a list of screens where the bottom tab bar should be displayed, which is only the four main screens. Alongside this, we implemented a native method to control the visibility of the bottom bar. With this setup, when navigating within React Native, we check if the screen we’re moving to is on our list. If it is, we show the bottom bar; if not, we hide it by calling the bridge method.</p>
<ol start=3>
<li>
<p><strong>Double Navigation Headers</strong>: On iOS, we used the built-in navigation header with some customizations. When adding headers in React Native screens and navigating from native, two headers would appear—one native and one React Native.</p>
<p>To fix this, we hid and showed the headers whenever we crossed the boundry between native and react native. This is done by using our existing navigation methods.</p>
</li>
<li>
<p><strong>Infinite Nested Navigations:</strong> On both the native and React Native, the default behaviour when trying to navigate to the same screen or one that&rsquo;s already in the stack is to not add a new instance, which is great. However, with our setup, navigating between Native > RN > Native > RN > Native could lead to multiple instances of the same screen being added to the stack. While we minimized this by planning our screen transitions in a flow-like manner, it can still happen. To solve this and a few other issues, such as showing a force update screen without duplication, we kept track of the currently displayed screen and whether it’s managed by native or React Native. This allowed us to manage the navigation behavior correctly and prevent unnecessary screen duplications.</p>
</li>
<li>
<p><strong>Navigation Controllers:</strong> This wasn’t a concern on Android, but for iOS, we had to keep track of the last navigation controller used. This way, we knew which stack to push the <code>RCTRootView</code> onto when needed. This was a side effect of how our native codebase and navigation were structured, but it’s an important detail to mention.</p>
</li>
<li>
<p><strong>Modals, Present, Push, StartActivity, etc.:</strong> There are a few other nuances to handle since both iOS and Android have different types of navigations, like presenting a modal on iOS. We managed these similarly to our standard navigation by keeping track of the presentation method. This helped us properly dismiss modals using our bridged unified &ldquo;go back&rdquo; method.</p>
</li>
</ol>
<p>It&rsquo;s also a good idea to have a the <code>RCTBridge</code> instance be shared and reused in all <code>RCTRootViews</code> to avoid unnecessarily reloading the bundle. Along with initalizing an empty <code>RCTRootView</code> at native app start to avoid delays for first renders. We have a simple bundle init setup looking like this in IOS side with CodePush as our OTA updates provider.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=kd>private</span> <span class=kr>override</span> <span class=kd>init</span><span class=p>()</span> <span class=p>{</span>
  <span class=kc>super</span><span class=p>.</span><span class=kd>init</span><span class=p>()</span>

  <span class=cp>#if</span> <span class=cp>DEBUG</span>
  	<span class=kd>let</span> <span class=nv>jsBundleURL</span> <span class=p>=</span> <span class=n>RCTBundleURLProvider</span><span class=p>.</span><span class=n>sharedSettings</span><span class=p>().</span><span class=n>jsBundleURL</span><span class=p>(</span><span class=n>forBundleRoot</span><span class=p>:</span> <span class=s>&#34;index&#34;</span><span class=p>,</span> <span class=n>fallbackExtension</span><span class=p>:</span> <span class=kc>nil</span><span class=p>)</span>
  <span class=cp>#else</span>
  	<span class=kd>let</span> <span class=nv>jsBundleURL</span> <span class=p>=</span> <span class=n>CodePush</span><span class=p>.</span><span class=n>bundleURL</span><span class=p>()</span>
  <span class=cp>#endif</span>

  <span class=kc>self</span><span class=p>.</span><span class=n>bridge</span> <span class=p>=</span> <span class=n>RCTBridge</span><span class=p>(</span><span class=n>bundleURL</span><span class=p>:</span> <span class=n>jsBundleURL</span><span class=p>,</span> <span class=n>moduleProvider</span><span class=p>:</span> <span class=kc>nil</span><span class=p>,</span> <span class=n>launchOptions</span><span class=p>:</span> <span class=kc>nil</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><h2 id=notifications>Notifications<a hidden class=anchor aria-hidden=true href=#notifications>#</a></h2>
<p>We&rsquo;re already managing notifications on the native side—which we need to keep there—we also need to handle them in React Native. For example, this allows us to refresh a screen or perform other actions when a notification is received. We addressed this by emitting events from the native to React Native (<a href=https://reactnative.dev/docs/legacy/native-components-android#events>React Native Communication</a>) whenever we get a notification, with the goal of eventually moving all notification handling to React Native. Of course, this approach doesn&rsquo;t give us full control over notification handling since we&rsquo;re not directly influencing how notifications are managed. However, it serves as a temporary solution that meets our current use cases effectively.</p>
<p><strong>Note:</strong> To save yourself time and frustration, always test notifications on physical devices. Simulators often have numerous issues and inconsistencies, regardless of what Apple and Google&rsquo;s documentation suggests.</p>
<h2 id=state-sharing>State Sharing<a hidden class=anchor aria-hidden=true href=#state-sharing>#</a></h2>
<p>Starting with a native app means that all stored state resides in the native layer. This setup creates two separate places where the state can be modified. For example, if authentication is handled natively, the session is stored and used by the native API manager. However, any authenticated React Native screen isn’t aware of the native session, and vice versa. To address this, we need a shared state between the two sides.</p>
<p>There are several ways to approach this. We can use additional bridge methods or emit events to synchronize the state between native and React Native. This is the same strategy recommended by experts at Infinite.red. Since this is a critical part of our app and the interface between the two sides lacks static type checking or code generation (There is Nitro now), we suggest implementing strict runtime type checking using tools like Zod and adding tests to catch any issues early in development. Our goal is to eventually transition fully to React Native as more responsibilities shift there over time. Therefore, designing the state with this eventual move in mind is the approach we followed.</p>
<p>We also stored some of the state locally on the device for both native and React Native, using <code>UserDefaults</code> on iOS for example. For these states, we directly access and modify them with packages such as <code>react-native-default-preference</code>.</p>
<h2 id=extra>Extra<a hidden class=anchor aria-hidden=true href=#extra>#</a></h2>
<h3 id=android-activity-vs-fragments>Android Activity vs Fragments<a hidden class=anchor aria-hidden=true href=#android-activity-vs-fragments>#</a></h3>
<p>React Native documentation uses <strong>Activities</strong> as the primary method for integrating with existing applications. This approach is generally easier to implement and encounters fewer initial issues. However, it was harder to manage later on. The alternative is to use Fragments. Depending on the codebase, wrapping React fragments within a native activity might not be straightforward. Despite this, we found that using the Fragments greatly improved our workflow when embedding React screens in various parts of the native Android app, such as the bottom tab bar navigator.</p>
<h3 id=rtl-issues>RTL Issues<a hidden class=anchor aria-hidden=true href=#rtl-issues>#</a></h3>
<p>Our app supports both Arabic and English, with Arabic being a right-to-left (RTL) language. Getting RTL to work turned out to be quite challenging with this setup. We tried several solutions, but iOS wouldn’t change the RTL direction after rendering, and React Native seemed to have the same issue. In the end, we decided to have the native side update the RTL direction whenever the language changes and then reload the React Native bundle, effectively restarting the app.</p>
<h3 id=gestures-and-swipe-to-go-back>Gestures and Swipe to Go Back<a hidden class=anchor aria-hidden=true href=#gestures-and-swipe-to-go-back>#</a></h3>
<p>We needed to handle/override the native go back and swipe to go back events when navigating between native and React Native to makesure swiping works within React Native stack context, not to trigger a full <code>RCTRootView</code> to be swiped back unless the stack has nothing further to go back to.</p>
<h3 id=protected-screens>Protected Screens<a hidden class=anchor aria-hidden=true href=#protected-screens>#</a></h3>
<p>Depending on the setup, some authentication checks will need to be performed manually rather than being managed by the navigator itself. This wasn’t a big deal for us, as we mainly encountered it during the period when we had both native and React Native screens in the bottom tab bar at the same time.</p>
<h3 id=keyboad-avoid-issues>Keyboad Avoid Issues<a hidden class=anchor aria-hidden=true href=#keyboad-avoid-issues>#</a></h3>
<p>This isn&rsquo;t specific to migration, but if you&rsquo;re taking the hybrid route, you&rsquo;re likely not using Expo from the start. That means you&rsquo;ll need to handle keyboard avoiding views manually. This turned out to be a major challenge due to the differences in behavior between Android and iOS, especially with bottom sheets.</p>
<p>The only approach that worked for us was setting <code>android:windowSoftInputMode="adjustPan"</code> on our React container for Android and handling <code>KeyboardAvoidingView</code> behavior with:
<code>Platform.OS === 'ios' ? 'padding' : undefined</code>. Along with using keyboard show/hide events where necessary.</p>
<p>Another promising solution we haven&rsquo;t explored yet is <a href=https://github.com/kirillzyusko/react-native-keyboard-controller>react-native-keyboard-controller</a>. Additionally, <a href=https://docs.expo.dev/guides/keyboard-handling/>Expo&rsquo;sdocumentation</a> on keyboard handling is a useful resource.</p>
<h2 id=timeline-and-metrics>Timeline and Metrics<a hidden class=anchor aria-hidden=true href=#timeline-and-metrics>#</a></h2>
<ul>
<li><strong>Initial discussions & research</strong>: August 14, 2023</li>
<li><strong>First commit</strong>: Sep 25, 2023</li>
<li><strong>Major scaffolding and shell setup done</strong>: Sept 28, 2023</li>
<li><strong>First Internal build with React Native shipped for testing</strong>: October 28, 2023</li>
<li><strong>First build with React Native shipped to production</strong>: May 27, 2024</li>
<li><strong>Full migration to React Native</strong>: Feb 10, 2025</li>
</ul>
<h3 id=frequency-of-releases-before-and-after-shipping-react-native>Frequency of releases before and after shipping React Native<a hidden class=anchor aria-hidden=true href=#frequency-of-releases-before-and-after-shipping-react-native>#</a></h3>
<p align=center>
<img src=/images/rn-migration/image-20250108162115113.png>
</p>
<h3 id=number-of-internal-builds-sent-for-testing-before-and-after-shipping-react-native>Number of internal builds sent for testing before and after shipping React Native<a hidden class=anchor aria-hidden=true href=#number-of-internal-builds-sent-for-testing-before-and-after-shipping-react-native>#</a></h3>
<p>This serves as a useful metric that can indirectly reflect the amount of testing and rebuilding needed for native modifications compared to React Native, which tends to slow down the development cycle.</p>
<p align=center>
<img src=/images/rn-migration/image-20250108162503702.png>
</p>
<h3 id=contributions-before-and-after-shipping-react-native>Contributions before and after shipping React Native<a hidden class=anchor aria-hidden=true href=#contributions-before-and-after-shipping-react-native>#</a></h3>
<p>Both the number of team contributors to the app and the volume of additions have increased.</p>
<p align=center>
<img src=/images/rn-migration/image-20250108163410999.png>
</p>
<p align=center>
<img src=/images/rn-migration/image-20250108163218251.png>
</p>
<h2 id=areas-for-improvement>Areas for Improvement<a hidden class=anchor aria-hidden=true href=#areas-for-improvement>#</a></h2>
<p>You may notice that there was a considerable amount of time between our first commit and the first production release. However, this timeline and outcome was still better for us than completing a full rewrite. By our first react native code release, we had already released numerous internal builds to the team for testing. We had completed many major screens, flows, and many smaller ones, along with implementing state sharing, navigation, payments, monitoring, and other key aspects of the app. We believe this should and could have been accomplished much earlier, with smaller more frequent releases. However, the flows we initially chose to transition included numerous native modules and were not the most effective starting points for delivering this to users quickly. This shows how crucial it is to take the time to plan and research for a project like this. We recommend truly understanding your app flows and coming up with a plan according to previous suggestions with the intention of getting this to your users sooner.</p>
<p>We also focused most of our efforts in getting IOS working smoothly, resulting in Android being somewhat neglected. This situation is partly due to our small team managing multiple large projects simultaneously. Naturally, this challenge extends beyond just migration. We should approach each project by considering both platforms from the start, and continuously planning for both. We recommend giving more thought to both platforms when planning the migration. This also ties into the previous point of understanding your app’s workflows and deciding which ones to prioritize first for the transition. Sometimes, depending on your codebase, a workflow that makes sense to start with on iOS might become challenging to implement on Android, or the other way around. When deciding on a flow or a screen you need to consider it on both platforms.</p>
<h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2>
<p>Migrating from a native codebase to React Native was both challenging and rewarding for us. Now, every engineer on our team can handle tasks from requirements gathering to initiating planning and implementation across both the backend and frontend, embracing a true full-stack approach. This migration has granted us greater flexibility, increased our productivity, collaboration, shipping speed all while reducing the cognitive load of every fix and feature implementation.</p>
<h2 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h2>
<p>Nearform&rsquo;s multi-part <a href=https://www.nearform.com/insights/adding-react-native-to-a-complex-app-part-1-planning/>guide</a> is particularly valuable, as it thoroughly addresses many of the challenges we faced and offers in great detail effective approaches and solutions. I unfortunately only found it while writing this post. I think it&rsquo;s a must read for anyone planning to go through the migration.</p>
<ul>
<li><a href=https://martinfowler.com/articles/strangler-fig-mobile-apps.html>Strangler Fig Pattern for Mobile Apps</a></li>
<li><a href="https://reactnative.dev/docs/integration-with-existing-apps?language=kotlin">React Native - Integration with Existing Apps</a></li>
<li><a href=https://www.nearform.com/insights/adding-react-native-to-a-complex-app-part-1-planning/>Nearform - Adding React Native to a Complex App</a></li>
<li><a href=https://www.callstack.com/blog/migration-to-react-native>Callstack - Migration to React Native</a></li>
<li><a href=https://agileengine.com/migrate-to-react-native/>Agile engine - Migrate to React Native</a></li>
<li><a href=https://shopify.engineering/migrating-our-largest-mobile-app-to-react-native>Shopify - Migrating Our Largest Mobile App to React Native</a></li>
<li><a href=https://github.com/electrode-io>Walmart labs - Electrode</a></li>
</ul>
<h2 id=thanks>Thanks<a hidden class=anchor aria-hidden=true href=#thanks>#</a></h2>
<p>A huge thank you to the team at <a href=https://github.com/Ejaro>Ejaro</a> for their amazing work, and <a href=https://omar.engineer>Omar Bahareth</a> for his support and guidance.</p>
<p>Thanks a lot to <a href=https://x.com/jamonholmgren>Jamon</a>, as well as everyone at <a href=https://infinite.red>Infinite Red</a> for their invaluable insights.</p>
</div>
<footer class=post-footer>
<ul class=post-tags dir=ltr>
</ul>
<nav class=paginav>
<a class=next href=https://wes4m.io/posts/5vps/>
<span class=title>Next »</span>
<br>
<span>Lessons from a $5 VPS, Bad Design, and a Traffic Spike</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2025 <a href=https://wes4m.io/>wes4m</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>